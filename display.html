<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Polling - Keyword Canvas</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
</head>
<body class="concept-body">
    <div class="concept-wrapper">
        <header class="concept-top">
            <div class="concept-select">
                <label class="concept-label" for="questionSelect">질문 선택</label>
                <div class="concept-select-pill">
                    <select id="questionSelect" aria-label="질문 선택"></select>
                    <span class="concept-status" id="conceptStatus">로딩 중…</span>
                </div>
            </div>
            <div class="concept-question-inline">
                <h2 id="conceptQuestion">질문</h2>
                <p class="concept-question-desc">답변에서 추출된 단어만을 미니멀하게 배치합니다</p>
            </div>
            <div class="concept-brand-icon" aria-hidden="true">
                <span></span>
                <span></span>
            </div>
        </header>

        <main class="concept-cloud">
            <div class="concept-words" id="conceptWords"></div>
        </main>

        <footer class="concept-bottom">
            <div class="concept-participation">
                <div class="concept-link">
                    <span>참여 링크</span>
                    <p id="conceptLink"></p>
                </div>
                <div id="conceptQrCode"></div>
            </div>
            <div class="concept-meta-controls">
                <div class="concept-meta">
                    <div>
                        <p class="concept-label">누적 답변</p>
                        <p class="concept-value" id="conceptTotal">0</p>
                    </div>
                    <div>
                        <p class="concept-label">업데이트</p>
                        <p class="concept-value" id="conceptUpdated">-</p>
                    </div>
                </div>
                <div class="concept-actions">
                    <button class="concept-action" id="toggleMock">모의</button>
                    <button class="concept-action" id="shuffleWords">재배치</button>
                </div>
            </div>
        </footer>
    </div>

    <script src="supabase-config.js"></script>
    <script>
        const questionSelect = document.getElementById('questionSelect');
        const conceptQuestion = document.getElementById('conceptQuestion');
        const conceptStatus = document.getElementById('conceptStatus');
        const wordsLayer = document.getElementById('conceptWords');
        const conceptTotal = document.getElementById('conceptTotal');
        const conceptUpdated = document.getElementById('conceptUpdated');
        const conceptLink = document.getElementById('conceptLink');
        const qrCodeContainer = document.getElementById('conceptQrCode');
        const toggleMockBtn = document.getElementById('toggleMock');
        const shuffleBtn = document.getElementById('shuffleWords');

        const params = new URLSearchParams(window.location.search);
        let currentQuestionId = QUESTIONS[0].id;
        let isMockMode = params.get('mock') === '1';
        let pollingInterval = null;
        let simulationInterval = null;
        let mockAnswers = [];
        let wordParticles = [];
        let qrCodeInstance = null;
        let isSimulationRunning = false;

        const KEYWORDS = ['연결', '성장', '도전', '몰입', '설렘', '공감', '협업', '집중', '영감', '감동', '시너지', '에너지', '환대', '몰두', '발견', '혁신', '팀워크', '지원', '아이디어', '탐험', '성찰', '축제', '유연함', '치열함', '여유', '흥미', '모험', '발표', '피드백', '브레인스토밍', 'collaboration', 'momentum', 'breakthrough', 'catalyst', 'insight', 'iteration', 'community', 'confidence', 'empathy', 'curiosity'];
        const PREFIXES = ['따뜻한', '깊은', '새로운', '반짝이는', '집중의', '장난기 있는', '강렬한', '잔잔한', '선명한'];
        const SUFFIXES = ['무드', '아이디어', '영감', '에너지', '발견', '시간', '순간', '대화', '시선'];

        function initSelect() {
            QUESTIONS.forEach(q => {
                const option = document.createElement('option');
                option.value = q.id;
                option.textContent = q.question;
                questionSelect.appendChild(option);
            });
            const initial = Number(params.get('question'));
            if (initial && QUESTIONS.find(q => q.id === initial)) currentQuestionId = initial;
            questionSelect.value = currentQuestionId;
        }

        function updateQuestionMeta(question) {
            conceptQuestion.textContent = question.question;
            document.documentElement.style.setProperty('--concept-accent', question.color || '#7c3aed');
            const answerUrl = new URL(window.location.href);
            answerUrl.pathname = answerUrl.pathname.replace(/[^/]+$/, 'answer.html');
            answerUrl.search = `?question=${question.id}`;
            answerUrl.hash = '';
            const urlString = answerUrl.toString();
            conceptLink.textContent = urlString;

            if (qrCodeInstance) {
                qrCodeInstance.clear();
                qrCodeInstance.makeCode(urlString);
            } else {
                qrCodeInstance = new QRCode(qrCodeContainer, { text: urlString, width: 96, height: 96, colorDark: "#0f172a", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H });
            }
        }

        function generateSingleMockAnswer(questionId, index) {
            const word = KEYWORDS[index % KEYWORDS.length];
            const prefix = PREFIXES[Math.floor(Math.random() * PREFIXES.length)];
            const suffix = SUFFIXES[Math.floor(Math.random() * SUFFIXES.length)];
            const mode = Math.random();
            const text = mode < 0.3 ? `${prefix} ${word}` : mode < 0.6 ? `${word} ${suffix}` : word;
            return { id: `${questionId}-${index}-${Date.now()}`, question_id: questionId, answer_text: text, created_at: new Date().toISOString() };
        }

        function extractWordInstances(answers) {
            const frequency = new Map();
            const instances = [];
            answers.forEach((answer, answerIndex) => {
                if (!answer.answer_text) return;
                const answerId = answer.id || `ans-${answerIndex}`;
                const tokens = answer.answer_text.split(/[\s,.;!?"'()\[\]{}]+/).map(token => token.replace(/^[^0-9a-zA-Z가-힣]+|[^0-9a-zA-Z가-힣]+$/g, '').trim()).filter(token => token.length > 1);
                tokens.forEach((token, tokenIndex) => {
                    frequency.set(token, (frequency.get(token) || 0) + 1);
                    instances.push({ text: token, instanceId: `${answerId}-${tokenIndex}` });
                });
            });
            return { instances, frequency };
        }

        function runForceSimulation() {
            if (isSimulationRunning) return;
            isSimulationRunning = true;

            const containerWidth = wordsLayer.offsetWidth;
            const containerHeight = wordsLayer.offsetHeight;
            const centerW = containerWidth / 2;
            const centerH = containerHeight / 2;

            // Initialize particles that are not yet initialized
            wordParticles.forEach(p => {
                if (p.width === 0) { // New particle
                    const rect = p.el.getBoundingClientRect();
                    p.width = rect.width;
                    p.height = rect.height;
                    p.x = centerW + (Math.random() - 0.5) * containerWidth * 0.1;
                    p.y = centerH + (Math.random() - 0.5) * containerHeight * 0.1;
                }
            });

            const iterations = 120;
            for (let i = 0; i < iterations; i++) {
                // Apply forces
                for (let j = 0; j < wordParticles.length; j++) {
                    const p1 = wordParticles[j];

                    // Repulsion from other particles
                    for (let k = j + 1; k < wordParticles.length; k++) {
                        const p2 = wordParticles[k];
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = (p1.width + p2.width) / 2 * 0.8; // Add some padding

                        if (distance < minDistance && distance > 0) {
                            const force = (minDistance - distance) * 0.05;
                            const angle = Math.atan2(dy, dx);
                            const fx = Math.cos(angle) * force;
                            const fy = Math.sin(angle) * force;
                            p1.vx += fx;
                            p1.vy += fy;
                            p2.vx -= fx;
                            p2.vy -= fy;
                        }
                    }

                    // Centering force
                    const centerDx = p1.x - centerW;
                    const centerDy = p1.y - centerH;
                    p1.vx -= centerDx * 0.0001;
                    p1.vy -= centerDy * 0.0001;
                }

                // Update positions
                for (const p of wordParticles) {
                    p.vx *= 0.9; // Damping
                    p.vy *= 0.9;
                    p.x += p.vx;
                    p.y += p.vy;
                }
            }

            // Final update to DOM
            wordParticles.forEach(p => {
                p.el.style.left = `${p.x.toFixed(2)}px`;
                p.el.style.top = `${p.y.toFixed(2)}px`;
                p.el.style.transform = 'translate(-50%, -50%)';
            });
            
            isSimulationRunning = false;
        }

        function renderWords(items) {
            if (isSimulationRunning) return;

            const existingEls = new Map();
            wordParticles.forEach(p => existingEls.set(p.el.textContent, p));

            if (!items.instances.length && !wordParticles.length) {
                wordsLayer.innerHTML = '<div class="concept-empty">첫 번째 단어를 기다리고 있어요</div>';
                return;
            } else if (items.instances.length > 0 && wordsLayer.querySelector('.concept-empty')) {
                wordsLayer.innerHTML = '';
            }

            const uniqueWords = [...new Map(items.instances.map(item => [item.text, item])).values()];
            const maxWords = 150; // Limit words for better layout
            const limited = uniqueWords.slice(0, maxWords);
            const newWordTexts = new Set(limited.map(item => item.text));

            // Remove old particles
            wordParticles = wordParticles.filter(p => {
                if (!newWordTexts.has(p.el.textContent)) {
                    p.el.classList.add('concept-word-hidden');
                    setTimeout(() => p.el.remove(), 300);
                    return false;
                }
                return true;
            });

            const maxWeight = Math.max(...limited.map(item => items.frequency.get(item.text) || 1));
            const palette = ['#ef4444', '#f97316', '#facc15', '#22c55e', '#14b8a6', '#0ea5e9', '#3b82f6', '#6366f1', '#a855f7', '#ec4899'];

            limited.forEach((item, index) => {
                if (existingEls.has(item.text)) return;

                const wordEl = document.createElement('span');
                wordEl.className = 'concept-word';
                wordEl.textContent = item.text;

                const weight = items.frequency.get(item.text) || 1;
                const weightRatio = weight / maxWeight;
                wordEl.style.fontSize = `${(0.8 + weightRatio * 0.6).toFixed(2)}rem`;
                wordEl.style.color = palette[index % palette.length];
                wordEl.style.opacity = (0.7 + weightRatio * 0.3).toFixed(2);

                if (weightRatio > 0.7) wordEl.classList.add('concept-word-hero');
                else if (weightRatio > 0.4) wordEl.classList.add('concept-word-accent');
                
                wordsLayer.appendChild(wordEl);

                wordParticles.push({
                    el: wordEl,
                    x: 0, y: 0, vx: 0, vy: 0, width: 0, height: 0
                });
            });

            // Defer simulation to allow DOM to update
            setTimeout(runForceSimulation, 50);
        }

        async function fetchRealAnswers() {
            const question = QUESTIONS.find(q => q.id === Number(currentQuestionId));
            if (!question) return;
            conceptStatus.textContent = '동기화 중…';
            const { success, data } = await getAnswers(question.id, 300);
            if (success) {
                const wordItems = extractWordInstances(data);
                renderWords(wordItems);
                conceptTotal.textContent = data.length;
            }
            conceptUpdated.textContent = new Date().toLocaleTimeString();
            conceptStatus.textContent = '실시간';
        }

        function stopAllIntervals() {
            if (pollingInterval) clearInterval(pollingInterval);
            if (simulationInterval) clearInterval(simulationInterval);
            pollingInterval = null;
            simulationInterval = null;
        }
        
        function resetDisplay() {
            stopAllIntervals();
            mockAnswers = [];
            wordParticles = [];
            wordsLayer.innerHTML = '';
            conceptTotal.textContent = '0';
        }

        function startRealtimeSimulation() {
            stopAllIntervals();
            resetDisplay();
            let count = 0;
            conceptStatus.textContent = '모의 모드 (실시간)';
            
            simulationInterval = setInterval(() => {
                if (count >= 300) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    conceptStatus.textContent = '모의 모드 (완료)';
                    return;
                }
                const newAnswer = generateSingleMockAnswer(currentQuestionId, count);
                mockAnswers.unshift(newAnswer);
                const wordItems = extractWordInstances(mockAnswers);
                renderWords(wordItems);
                conceptTotal.textContent = mockAnswers.length;
                conceptUpdated.textContent = new Date().toLocaleTimeString();
                count++;
            }, 1000);
        }

        function startRealDataPolling() {
            stopAllIntervals();
            resetDisplay();
            fetchRealAnswers();
            pollingInterval = setInterval(fetchRealAnswers, 2000);
        }

        questionSelect.addEventListener('change', () => {
            currentQuestionId = Number(questionSelect.value);
            const question = QUESTIONS.find(q => q.id === currentQuestionId);
            updateQuestionMeta(question);
            if (isMockMode) startRealtimeSimulation();
            else startRealDataPolling();
        });

        toggleMockBtn.addEventListener('click', () => {
            isMockMode = !isMockMode;
            toggleMockBtn.classList.toggle('active', isMockMode);
            if (isMockMode) startRealtimeSimulation();
            else startRealDataPolling();
        });

        shuffleBtn.addEventListener('click', () => {
            if (wordParticles.length === 0 || isSimulationRunning) return;
            // Re-run simulation on existing particles
            runForceSimulation();
        });
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (wordParticles.length > 0) {
                    runForceSimulation();
                }
            }, 200);
        });

        // --- Initial Load ---
        initSelect();
        const initialQuestion = QUESTIONS.find(q => q.id === currentQuestionId);
        updateQuestionMeta(initialQuestion);
        if (isMockMode) {
            toggleMockBtn.classList.add('active');
            startRealtimeSimulation();
        } else {
            startRealDataPolling();
        }
    </script>
</body>
</html>
