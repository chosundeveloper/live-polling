<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Polling - Mutalisk</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/motion@11.11.13/dist/motion.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body class="concept-body">
    <div class="concept-wrapper">
        <header class="concept-top">
            <div class="concept-title-nav">
                <button class="concept-nav-btn" id="prevQuestionBtn" aria-label="Ïù¥Ï†Ñ ÏßàÎ¨∏">‚Äπ</button>
                <div class="concept-question-display">
                    <h2 id="conceptQuestion">ÏßàÎ¨∏ Î°úÎî© Ï§ë...</h2>
                    <p class="concept-question-desc" id="questionCounter"></p>
                </div>
                <button class="concept-nav-btn concept-nav-btn-next" id="nextQuestionBtn" aria-label="Îã§Ïùå ÏßàÎ¨∏">‚Ä∫</button>
            </div>
        </header>

        <main class="concept-cloud">
            <div class="concept-words" id="conceptWords"></div>
            <div class="concept-overlay concept-overlay-bottom-left">
                <div class="concept-qr-card">
                    <div class="concept-qr-box" id="conceptQrCode"></div>
                    <div class="concept-qr-meta">
                        <div>
                            <p class="concept-label">ÎàÑÏ†Å ÎãµÎ≥Ä</p>
                            <p class="concept-value" id="conceptTotal">0</p>
                        </div>
                        <div class="concept-timer-row">
                            <div>
                                <p class="concept-label">ÌÉÄÏù¥Î®∏</p>
                                <p class="concept-value" id="conceptUpdated">10:00</p>
                            </div>
                            <button class="concept-action concept-action-ghost" id="toggleMock">Î™®Ïùò</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        console.log('Script started executing'); // Very early log

        // Questions loaded from supabase-config.js

        // Public URL for QR code (GitHub Pages)
        const PUBLIC_URL = 'https://chosundeveloper.github.io/live-polling';

        // Timer state
        let questionStartTime = null;

        // --- DOM Elements ---
        const conceptQuestion = document.getElementById('conceptQuestion');
        const questionCounter = document.getElementById('questionCounter');
        const wordsLayer = document.getElementById('conceptWords');
        const conceptTotal = document.getElementById('conceptTotal');
        const conceptUpdated = document.getElementById('conceptUpdated');
        const qrCodeContainer = document.getElementById('conceptQrCode');
        const toggleMockBtn = document.getElementById('toggleMock');
        const prevQuestionBtn = document.getElementById('prevQuestionBtn');
        const nextQuestionBtn = document.getElementById('nextQuestionBtn');

        // --- State ---
        const params = new URLSearchParams(window.location.search);
        let currentQuestionIndex = 0;
        let isMockMode = params.get('mock') === '1';
        let realtimeChannel = null;
        let simulationInterval = null;
        let mockAnswers = [];
        let wordParticles = [];
        let hiddenWords = [];
        let qrCodeInstance = null;
        let animationFrameId = null;
        let timerInterval = null;
        let timerDeadline = null;
        let d3Simulation = null;
        let sessionStartTime = null; // ÌéòÏù¥ÏßÄ Î°úÎìú ÏãúÏ†ê

        // --- Constants ---
        const KEYWORDS = ['Ïó∞Í≤∞', 'ÏÑ±Ïû•', 'ÎèÑÏ†Ñ', 'Î™∞ÏûÖ', 'ÏÑ§Î†ò', 'Í≥µÍ∞ê', 'ÌòëÏóÖ', 'ÏßëÏ§ë', 'ÏòÅÍ∞ê', 'Í∞êÎèô', 'ÏãúÎÑàÏßÄ', 'ÏóêÎÑàÏßÄ', 'ÌôòÎåÄ', 'Î™∞Îëê', 'Î∞úÍ≤¨', 'ÌòÅÏã†', 'ÌåÄÏõåÌÅ¨', 'ÏßÄÏõê', 'ÏïÑÏù¥ÎîîÏñ¥', 'ÌÉêÌóò', 'ÏÑ±Ï∞∞', 'Ï∂ïÏ†ú', 'Ïú†Ïó∞Ìï®', 'ÏπòÏó¥Ìï®', 'Ïó¨Ïú†', 'Ìù•ÎØ∏', 'Î™®Ìóò', 'Î∞úÌëú', 'ÌîºÎìúÎ∞±', 'Î∏åÎ†àÏù∏Ïä§ÌÜ†Î∞ç', 'collaboration', 'momentum', 'breakthrough', 'catalyst', 'insight', 'iteration', 'community', 'confidence', 'empathy', 'curiosity'];
        const PREFIXES = ['Îî∞ÎúªÌïú', 'ÍπäÏùÄ', 'ÏÉàÎ°úÏö¥', 'Î∞òÏßùÏù¥Îäî', 'ÏßëÏ§ëÏùò', 'Ïû•ÎÇúÍ∏∞ ÏûàÎäî', 'Í∞ïÎ†¨Ìïú', 'ÏûîÏûîÌïú', 'ÏÑ†Î™ÖÌïú'];
        const SUFFIXES = ['Î¨¥Îìú', 'ÏïÑÏù¥ÎîîÏñ¥', 'ÏòÅÍ∞ê', 'ÏóêÎÑàÏßÄ', 'Î∞úÍ≤¨', 'ÏãúÍ∞Ñ', 'ÏàúÍ∞Ñ', 'ÎåÄÌôî', 'ÏãúÏÑ†'];
        const TEXT_ANSWERS = [
            'Ïò§Îäò Ï†ïÎßê Ï¢ãÏùÄ Î∞úÌëúÎ•º Îì§Ïñ¥ÏÑú Í∏∞Î∂ÑÏù¥ Ï¢ãÏïÑÏöî!',
            'ÏÉàÎ°úÏö¥ ÏïÑÏù¥ÎîîÏñ¥Í∞Ä Îñ†Ïò¨ÎùºÏÑú ÏÑ§Î†àÎÑ§Ïöî',
            'ÌåÄÏõêÎì§Í≥ºÏùò ÌòëÏóÖÏù¥ Ï¶êÍ±∞Ïõ†ÏäµÎãàÎã§',
            'ÏßÄÍ∏àÍπåÏßÄ Î∞∞Ïö¥ ÎÇ¥Ïö©Ïù¥ Ï†ïÎßê Ïú†ÏùµÌñàÏñ¥Ïöî',
            'ÏïûÏúºÎ°úÏùò ÌîÑÎ°úÏ†ùÌä∏Í∞Ä Í∏∞ÎåÄÎê©ÎãàÎã§',
            'Ïò§Îäò ÏÑ∏ÏÖòÏù¥ Îß§Ïö∞ Ïù∏ÏÉÅ ÍπäÏóàÏñ¥Ïöî',
            'ÎèôÎ£åÎì§Ïùò Ïó¥Ï†ïÏóê ÏûêÍ∑πÎ∞õÏïòÏäµÎãàÎã§',
            'Ïã§Î¨¥Ïóê Î∞îÎ°ú Ï†ÅÏö©Ìï† Ïàò ÏûàÏùÑ Í≤É Í∞ôÏïÑÏöî',
            'Í∞ïÏÇ¨ÎãòÏùò ÏÑ§Î™ÖÏù¥ Î™ÖÌôïÌï¥ÏÑú Ïù¥Ìï¥ÌïòÍ∏∞ Ïâ¨Ïõ†Ïñ¥Ïöî',
            'ÏßàÏùòÏùëÎãµ ÏãúÍ∞ÑÏù¥ ÎèÑÏõÄÏù¥ ÎßéÏù¥ ÎêêÏäµÎãàÎã§',
            'ÎÑ§Ìä∏ÏõåÌÇπ ÏãúÍ∞ÑÏù¥ Ï¢ãÏïòÏñ¥Ïöî',
            'ÏÉàÎ°úÏö¥ Í¥ÄÏ†êÏùÑ ÏñªÍ≤å ÎêòÏóàÏäµÎãàÎã§',
            'Ïã§Ïäµ Í≥ºÏ†ïÏù¥ Ïû¨ÎØ∏ÏûàÏóàÏñ¥Ïöî',
            'Îã§Ïùå ÏÑ∏ÏÖòÎèÑ Í∏∞ÎåÄÍ∞Ä ÌÅ¨ÎÑ§Ïöî',
            'Ïò§Îäò ÌïòÎ£®Í∞Ä ÎúªÍπäÏóàÏäµÎãàÎã§'
        ];
        const MAX_WORDS = 150;
        const MIN_FONT_SIZE = 18;
        const MAX_FONT_SIZE = 32;
        const MAX_PARTICLE_SPEED = 0.001;
        const MIN_SEPARATION = 150;
        const DEFAULT_PARTICLE_WIDTH = 48;
        const DEFAULT_PARTICLE_HEIGHT = 22;
        const INTRO_DURATION_BASE = 180000; // extremely slow duration (3 minutes)
        const INTRO_DURATION_VARIANCE = 20000;
        const INTRO_BLOOM_JITTER = 0; // No bloom
        const INTRO_SPIRAL_TWIST = 0; // No spiral
        const INTRO_SWAY_AMPLITUDE = 0; // No sway
        const INTRO_SWAY_FREQUENCY = 1.1;
        const INTRO_STAGE_MIN_RADIUS = 10;
        const INTRO_STAGE_MAX_RADIUS = 40;
        const INTRO_CLUSTER_RATIO = 0.3; // 30% for gathering, 70% for spreading (slower spread)
        const INTRO_CLUSTER_SWAY = 0;
        const INTRO_CLUSTER_PADDING = 120;
        const OUTWARD_DRIFT_FORCE = 0.000002;
        const TARGET_ATTRACTION_FORCE = 0.000001;
        const RADIAL_FORCE = 0.000004;
        const MIN_WORD_LIFETIME = 7000;
        const TIMER_DURATION_MS = 600 * 1000; // 600 seconds (10 minutes)
        const COLOR_PALETTE = ['#5e4fa2', '#3288bd', '#66c2a5', '#abdda4', '#e6f598', '#fee08b', '#fdae61', '#f46d43', '#d53e4f', '#9e0142'];
        const MAX_CELL_SPREAD_RATIO = 0.38; // Expanded for much more space
        const INNER_CORE_RATIO = 0.06; // Inner core that stays stable (very small)
        const PUSH_THRESHOLD_RATIO = 0.10; // Start pushing outward very early

        function selectWordColor(weightRatio, index) {
            // Truly random color selection - no pattern
            return COLOR_PALETTE[Math.floor(Math.random() * COLOR_PALETTE.length)];
        }
        window.selectWordColor = selectWordColor;

        function splitWordIntoCharacters(wordEl) {
            if (!wordEl || wordEl.dataset.charsSplit === '1') {
                return wordEl?.querySelectorAll('.concept-char');
            }
            const text = wordEl.textContent;
            wordEl.textContent = '';
            const fragment = document.createDocumentFragment();
            for (const char of text) {
                const span = document.createElement('span');
                span.className = 'concept-char';
                span.textContent = char === ' ' ? '\u00A0' : char;
                fragment.appendChild(span);
            }
            wordEl.appendChild(fragment);
            wordEl.dataset.charsSplit = '1';
            return wordEl.querySelectorAll('.concept-char');
        }

        function animateWordEntry(wordEl) {
            if (!window.motion || !wordEl) return;
            const chars = splitWordIntoCharacters(wordEl);
            if (!chars || chars.length === 0) return;
            const isVertical = wordEl.classList.contains('concept-word-vertical');
            const { animate, stagger, spring } = window.motion;

            wordEl.style.setProperty('--concept-scale', '0.8');

            const envelopeSpring = spring({ stiffness: 100, damping: 28, mass: 1.2 });
            const letterSpring = spring({ stiffness: 85, damping: 26, mass: 1.0 });

            animate(wordEl, { opacity: [0, 0.96] }, {
                duration: 0.65,
                easing: [0.25, 0.1, 0.25, 1.0]
            });

            animate(wordEl, { '--concept-scale': ['0.8', '1'] }, {
                easing: envelopeSpring,
                duration: 1.2
            });

            animate(chars, {
                opacity: [0, 1],
                y: [isVertical ? 18 : 32, 0],
                x: [isVertical ? -12 : 0, 0],
                rotateX: [isVertical ? 0 : -24, 0],
                skewY: [isVertical ? -6 : 0, 0]
            }, {
                easing: letterSpring,
                duration: 1.35,
                delay: stagger(0.018)
            });
        }

        function getCloudBounds() {
            const rect = wordsLayer.getBoundingClientRect();
            let width = rect.width;
            let height = rect.height;
            if (width > 10 && height > 10) {
                return { width, height };
            }
            const parentRect = wordsLayer.parentElement?.getBoundingClientRect();
            width = parentRect?.width || window.innerWidth;
            height = parentRect?.height || window.innerHeight;
            return { width, height };
        }

        const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));



        function findClusterPosition(existing, centerW, centerH, baseRadius, baseAngle) {
            if (!existing.length) {
                const x = centerW + Math.cos(baseAngle) * baseRadius;
                const y = centerH + Math.sin(baseAngle) * baseRadius;
                return { x, y };
            }

            let best = null;
            let bestScore = -Infinity;
            for (let attempt = 0; attempt < 500; attempt++) {
                const angle = baseAngle + attempt * (GOLDEN_ANGLE * 0.25) + (Math.random() - 0.5) * 0.25;
                const radius = baseRadius + attempt * 1;
                const x = centerW + Math.cos(angle) * radius;
                const y = centerH + Math.sin(angle) * radius;
                let minDist = Infinity;
                for (const p of existing) {
                    const dx = x - p.x;
                    const dy = y - p.y;
                    const dist = Math.hypot(dx, dy);
                    const needed = ((p.width || DEFAULT_PARTICLE_WIDTH) / 2) + INTRO_CLUSTER_PADDING;
                    if (dist < needed) {
                        minDist = dist - needed;
                        break;
                    }
                    minDist = Math.min(minDist, dist - needed);
                }
                if (minDist >= INTRO_CLUSTER_PADDING) {
                    return { x, y };
                }
                if (minDist > bestScore) {
                    bestScore = minDist;
                    best = { x, y };
                }
            }
            return best || { x: centerW + Math.cos(baseAngle) * baseRadius, y: centerH + Math.sin(baseAngle) * baseRadius };
        }

        function getSpiralGeometry(width, height, wordCount = MAX_WORDS) {
            const usableRadius = Math.min(width, height) * MAX_CELL_SPREAD_RATIO;
            const maxRadius = usableRadius * 0.95; // Slightly smaller to stay within bounds
            const minRadius = Math.max(25, maxRadius * 0.12);
            const count = Math.max(1, wordCount);
            const ringCount = Math.min(10, Math.max(3, Math.ceil(count / 25)));
            const ringSpan = (maxRadius - minRadius) / Math.max(1, ringCount - 1);
            const rings = [];
            let startIndex = 0;
            // Fill from outside to inside: start with maxRadius
            for (let i = 0; i < ringCount; i++) {
                const radius = maxRadius - ringSpan * i;
                const circumference = 2 * Math.PI * Math.max(40, radius);
                const capacity = Math.max(8, Math.round(circumference / 70));
                rings.push({ radius, start: startIndex, end: startIndex + capacity });
                startIndex += capacity;
            }
            // Ensure total coverage
            if (startIndex < count) {
                const extra = count - startIndex;
                rings[rings.length - 1].end += extra;
            }
            return { rings, count };
        }

        function assignParticleTarget(particle, centerW, centerH, geometry, spiralIndex = 0) {
            const clampedIndex = Math.max(0, Math.min(spiralIndex, geometry.count - 1));
            const ring = geometry.rings.find(r => clampedIndex < r.end) || geometry.rings[geometry.rings.length - 1];
            const radius = ring.radius;
            const angle = clampedIndex * GOLDEN_ANGLE;
            const jitterAngle = angle + (Math.random() - 0.5) * 0.04;
            const jitterRadius = radius + (Math.random() - 0.5) * Math.max(6, radius * 0.02);
            particle.targetX = centerW + Math.cos(jitterAngle) * jitterRadius;
            particle.targetY = centerH + Math.sin(jitterAngle) * jitterRadius;
            particle.spiralIndex = clampedIndex;
            particle.ringRadius = radius;
            particle.ringAngle = jitterAngle;
        }

        function getParticleDimensions(particle) {
            const width = particle.width || particle.el.offsetWidth || DEFAULT_PARTICLE_WIDTH;
            const height = particle.height || particle.el.offsetHeight || DEFAULT_PARTICLE_HEIGHT;
            particle.width = width;
            particle.height = height;
            return { width, height };
        }






        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimerDisplay() {
            if (!timerDeadline) {
                conceptUpdated.textContent = '10:00';
                return;
            }
            const remaining = Math.max(0, timerDeadline - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = String(Math.floor((remaining % 60000) / 1000)).padStart(2, '0');
            conceptUpdated.textContent = `${minutes}:${seconds}`;
            if (remaining <= 0) {
                stopTimer();
            }
        }

        function startTimer() {
            stopTimer();
            timerDeadline = Date.now() + TIMER_DURATION_MS;
            updateTimerDisplay();
            timerInterval = setInterval(updateTimerDisplay, 1000);
        }

        function updateIntroMotion(particle, centerW, centerH, timestamp) {
            if (particle.phase !== 'intro') return false;
            if (!particle.introStart) {
                particle.introStart = timestamp;
            }
            const duration = particle.introDuration || INTRO_DURATION_BASE;
            const rawProgress = duration <= 0 ? 1 : Math.min(1, (timestamp - particle.introStart) / duration);

            let targetX, targetY;

            // Move from center toward target position (outward)
            targetX = particle.originX + (particle.targetX - particle.originX) * rawProgress;
            targetY = particle.originY + (particle.targetY - particle.originY) * rawProgress;

            // Calculate force to move towards targetX, targetY at MAX_PARTICLE_SPEED
            const dx = targetX - particle.x;
            const dy = targetY - particle.y;
            const dist = Math.hypot(dx, dy);

            if (dist > 0.000001) { // Apply force if not already at target
                const forceMagnitude = dist * 0.005; // A small force to guide it
                particle.forceX += (dx / dist) * forceMagnitude;
                particle.forceY += (dy / dist) * forceMagnitude;
            }

            if (rawProgress >= 1) {
                particle.x = particle.targetX;
                particle.y = particle.targetY;
                particle.vx = 0;
                particle.vy = 0;
                particle.prevX = particle.targetX;
                particle.prevY = particle.targetY;
                particle.phase = 'idle';
                particle.introStart = null;
                particle.introDuration = null;
                return false;
            }
            return true;
        }

        function updateParticleTargets() {
            if (!wordParticles.length) return;
            const { width, height } = getCloudBounds();
            const centerW = width / 2;
            const centerH = height / 2;
            const geometry = getSpiralGeometry(width, height, wordParticles.length);
            wordParticles.forEach(p => assignParticleTarget(p, centerW, centerH, geometry, p.spiralIndex || 0));

            // Reinitialize D3 simulation with updated targets
            if (d3Simulation) {
                initD3Simulation();
            }
        }

        // --- Core Functions ---
        function updateQuestionMeta(question) {
            conceptQuestion.textContent = question.question;
            document.documentElement.style.setProperty('--concept-accent', question.color || '#7c3aed');

            // Set question start time for timer sync
            questionStartTime = Date.now();
            timerDeadline = questionStartTime + TIMER_DURATION_MS;

            // Pass START TIME (not deadline) so timer syncs correctly
            const urlString = `${PUBLIC_URL}/answer.html?q=${question.id}&startTime=${questionStartTime}`;

            console.log('üì± QR Code URL:', urlString);

            // Clear and regenerate QR code
            if (qrCodeContainer) {
                qrCodeContainer.innerHTML = '';
            }

            if (qrCodeInstance) {
                qrCodeInstance.clear();
                qrCodeInstance.makeCode(urlString);
            } else {
                qrCodeInstance = new QRCode(qrCodeContainer, { text: urlString, width: 96, height: 96, colorDark: "#0f172a", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H });
            }
        }
        
        function navigateToQuestion(index, options = {}) {
            const { force = false } = options;
            console.log('navigateToQuestion called with index:', index);
            const newIndex = Math.max(0, Math.min(QUESTIONS.length - 1, index));
            if (!force && newIndex === currentQuestionIndex && wordParticles.length > 0) {
                console.log('navigateToQuestion: Same question, particles exist, returning.');
                return;
            }

            currentQuestionIndex = newIndex;
            const question = QUESTIONS[currentQuestionIndex];

            updateQuestionMeta(question);
            questionCounter.textContent = `${currentQuestionIndex + 1} / ${QUESTIONS.length}`;

            prevQuestionBtn.disabled = currentQuestionIndex === 0;
            nextQuestionBtn.disabled = currentQuestionIndex === QUESTIONS.length - 1;

            resetDisplay();
            if (isMockMode) startRealtimeSimulation();
            else startRealtimeSubscription();
        }

        function extractWordInstances(answers) {
            console.log('extractWordInstances called with answers:', answers);
            const frequency = new Map();
            answers.forEach(answer => {
                console.log('Processing answer:', answer);
                if (!answer.answer_text) {
                    console.log('No answer_text found, skipping');
                    return;
                }
                console.log('answer_text:', answer.answer_text);
                const tokens = answer.answer_text.split(/[\s,.;!?"'()\[\]{}]+/).map(token => token.replace(/^[^0-9a-zA-ZÍ∞Ä-Ìû£]+|[^0-9a-zA-ZÍ∞Ä-Ìû£]+$/g, '').trim()).filter(token => token.length > 1);
                console.log('Extracted tokens:', tokens);
                tokens.forEach(token => frequency.set(token, (frequency.get(token) || 0) + 1));
            });
            console.log('Final frequency map:', frequency);
            return frequency;
        }

        // --- D3 Force Simulation Setup ---
        function initD3Simulation() {
            const { width: containerWidth, height: containerHeight } = getCloudBounds();
            const centerW = containerWidth / 2;
            const centerH = containerHeight / 2;

            if (d3Simulation) {
                d3Simulation.stop();
            }

            d3Simulation = d3.forceSimulation(wordParticles)
                .alphaDecay(0.0005)
                .velocityDecay(0.98)
                .alphaMin(0.0001)
                .force('collide', d3.forceCollide(d => {
                    const { width, height } = getParticleDimensions(d);
                    return Math.max(width, height) / 2 + MIN_SEPARATION / 2;
                }).strength(0.6).iterations(3))
                .force('gentle-separate', () => {
                    // Custom force: when words overlap, move the outer one toward cell boundary
                    const maxRadius = Math.min(containerWidth, containerHeight) * MAX_CELL_SPREAD_RATIO;

                    for (let i = 0; i < wordParticles.length; i++) {
                        for (let j = i + 1; j < wordParticles.length; j++) {
                            const p1 = wordParticles[i];
                            const p2 = wordParticles[j];

                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const distance = Math.hypot(dx, dy);

                            const { width: w1, height: h1 } = getParticleDimensions(p1);
                            const { width: w2, height: h2 } = getParticleDimensions(p2);
                            const minDist = (Math.max(w1, w2) / 2 + Math.max(h1, h2) / 2) + MIN_SEPARATION;

                            // Check if overlapping
                            if (distance < minDist && distance > 0) {
                                // Determine which is further from center
                                const dist1 = Math.hypot(p1.x - centerW, p1.y - centerH);
                                const dist2 = Math.hypot(p2.x - centerW, p2.y - centerH);

                                const outerWord = dist1 > dist2 ? p1 : p2;
                                const outerDist = dist1 > dist2 ? dist1 : dist2;

                                // Only move if it's in outer zone
                                const pushThreshold = maxRadius * (PUSH_THRESHOLD_RATIO / MAX_CELL_SPREAD_RATIO);

                                if (outerDist > pushThreshold) {
                                    // Push rapidly toward cell boundary (radial direction)
                                    const angle = Math.atan2(outerWord.y - centerH, outerWord.x - centerW);
                                    const overlap = minDist - distance;

                                    // Very gentle push with moderate distance-based multiplier
                                    const distRatio = outerDist / maxRadius;
                                    const pushStrength = overlap * 0.01 * (1 + distRatio * 0.5);

                                    outerWord.vx += Math.cos(angle) * pushStrength;
                                    outerWord.vy += Math.sin(angle) * pushStrength;
                                }
                            }
                        }
                    }
                })
                .force('radial', d3.forceRadial(d => d.ringRadius || 100, centerW, centerH).strength(0.005))
                .force('x', d3.forceX(d => d.targetX || centerW).strength(0.004))
                .force('y', d3.forceY(d => d.targetY || centerH).strength(0.004))
                .on('tick', () => {
                    const timestamp = performance.now();
                    const currentAlpha = d3Simulation.alpha();

                    wordParticles.forEach(p => {
                        // Apply intro motion override
                        if (p.phase === 'intro') {
                            updateIntroMotion(p, centerW, centerH, timestamp);
                            p.vx = (p.x - (p.prevX || p.x)) * 0.5;
                            p.vy = (p.y - (p.prevY || p.y)) * 0.5;
                        }

                        // Gradually reduce velocity as simulation stabilizes
                        if (currentAlpha < 0.1 && p.phase !== 'intro') {
                            p.vx *= 0.5;
                            p.vy *= 0.5;
                        }

                        // Hard limit on velocity to prevent spinning
                        const speed = Math.hypot(p.vx || 0, p.vy || 0);
                        if (speed > MAX_PARTICLE_SPEED) {
                            const ratio = MAX_PARTICLE_SPEED / speed;
                            p.vx *= ratio;
                            p.vy *= ratio;
                        }

                        // Strict boundary handling to keep within cell image
                        const maxRadius = Math.min(containerWidth, containerHeight) * MAX_CELL_SPREAD_RATIO;
                        const dx = p.x - centerW;
                        const dy = p.y - centerH;
                        const distFromCenter = Math.hypot(dx, dy);

                        // Soft boundary: slow down as approaching edge
                        if (distFromCenter > maxRadius * 0.9) {
                            const overRatio = (distFromCenter - maxRadius * 0.9) / (maxRadius * 0.1);
                            p.vx *= (1 - overRatio * 0.5);
                            p.vy *= (1 - overRatio * 0.5);
                        }

                        // Hard boundary: cannot exceed
                        if (distFromCenter > maxRadius) {
                            const angle = Math.atan2(dy, dx);
                            p.x = centerW + Math.cos(angle) * maxRadius;
                            p.y = centerH + Math.sin(angle) * maxRadius;
                            p.vx = 0;
                            p.vy = 0;
                        }

                        // Animate font size with D3 easing
                        const sizeDiff = p.targetFontSize - p.currentFontSize;
                        if (Math.abs(sizeDiff) > 0.01) {
                            p.currentFontSize += sizeDiff * 0.15;
                            p.el.style.fontSize = `${p.currentFontSize.toFixed(2)}px`;
                            const rect = p.el.getBoundingClientRect();
                            p.width = rect.width;
                            p.height = rect.height;
                        }

                        // Update DOM position
                        p.el.style.left = `${p.x}px`;
                        p.el.style.top = `${p.y}px`;

                        p.prevX = p.x;
                        p.prevY = p.y;
                    });
                });

            return d3Simulation;
        }

        // --- Legacy Simulation Loop (now simplified) ---
        function simulationLoop(timestamp = performance.now()) {
            if (!d3Simulation || wordParticles.length === 0) {
                if (wordParticles.length > 0) {
                    initD3Simulation();
                }
                animationFrameId = requestAnimationFrame(simulationLoop);
                return;
            }

            // D3 simulation handles everything via 'tick' event
            animationFrameId = requestAnimationFrame(simulationLoop);
        }

        function renderWords(frequencyMap) {
            console.log('renderWords called with frequencyMap:', frequencyMap);

            const existingParticles = new Map();
            const now = performance.now();
            wordParticles.forEach(p => {
                if (!p.bornAt) p.bornAt = now;
                existingParticles.set(p.el.textContent, p);
            });

            if (frequencyMap.size === 0 && wordParticles.length === 0) {
                wordsLayer.innerHTML = '<div class="concept-empty">Ï≤´ Î≤àÏß∏ Îã®Ïñ¥Î•º Í∏∞Îã§Î¶¨Í≥† ÏûàÏñ¥Ïöî</div>';
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            } else if (frequencyMap.size > 0 && wordsLayer.querySelector('.concept-empty')) {
                wordsLayer.innerHTML = '';
            }

            const sortedWords = [...frequencyMap.entries()].sort((a, b) => b[1] - a[1]);
            const limited = sortedWords.slice(0, MAX_WORDS).filter(([text]) => !hiddenWords.includes(text));
            const newWordTexts = new Set(limited.map(item => item[0]));
            
            wordParticles = wordParticles.filter(p => {
                if (!newWordTexts.has(p.el.textContent)) {
                    if (now - (p.bornAt || now) < MIN_WORD_LIFETIME) {
                        return true;
                    }
                    p.el.classList.remove('concept-word-visible');
                    p.el.classList.add('concept-word-hidden');
                    setTimeout(() => p.el.remove(), 700);
                    return false;
                }
                return true;
            });

            const lengths = limited.map(([text]) => text.length);
            const minLength = Math.min(...lengths) || 1;
            const maxLength = Math.max(...lengths) || 10;

            const { width: containerWidth, height: containerHeight } = getCloudBounds();
            const centerW = containerWidth / 2;
            const centerH = containerHeight / 2;
            const geometry = getSpiralGeometry(containerWidth, containerHeight, limited.length);

            limited.forEach(([text, weight], index) => {
                const lengthRatio = (maxLength - text.length) / (maxLength - minLength + 1);
                const targetFontSize = MIN_FONT_SIZE + (MAX_FONT_SIZE - MIN_FONT_SIZE) * lengthRatio;
                // Keep normal order: outer rings fill first, then move inward
                const spiralIndex = index;

                let particle = existingParticles.get(text);
                if (particle) {
                    particle.targetFontSize = targetFontSize;
                    if (particle.phase !== 'intro') {
                        assignParticleTarget(particle, centerW, centerH, geometry, spiralIndex);
                    }
                    particle.el.style.color = particle.color;
                } else {
                    const wordEl = document.createElement('span');
                    wordEl.className = 'concept-word';
                    wordEl.textContent = text;
                    const assignedColor = selectWordColor(weight / Math.max(...limited.map(item => item[1])), index);
                    wordEl.style.color = assignedColor;

                    const initialFontSize = MIN_FONT_SIZE + (MAX_FONT_SIZE - MIN_FONT_SIZE) * lengthRatio;
                    wordEl.style.fontSize = `${initialFontSize}px`;
                    
                    // Click to delete
                    wordEl.addEventListener('click', () => {
                        hiddenWords.push(text);

                        // D3 transition for smooth fade out
                        if (window.d3) {
                            d3.select(wordEl)
                                .transition()
                                .duration(600)
                                .ease(d3.easeCubicOut)
                                .style('opacity', 0)
                                .style('transform', 'scale(0.7)')
                                .on('end', () => {
                                    wordEl.remove();
                                    wordParticles = wordParticles.filter(p => p.el !== wordEl);
                                    if (wordParticles.length > 0) {
                                        updateParticleTargets();
                                        if (!animationFrameId) simulationLoop(performance.now());
                                    } else {
                                        wordsLayer.innerHTML = '<div class="concept-empty">Ï≤´ Î≤àÏß∏ Îã®Ïñ¥Î•º Í∏∞Îã§Î¶¨Í≥† ÏûàÏñ¥Ïöî</div>';
                                        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                                    }
                                });
                        } else {
                            wordEl.classList.remove('concept-word-visible');
                            wordEl.classList.add('concept-word-hidden');
                            setTimeout(() => {
                                wordEl.remove();
                                wordParticles = wordParticles.filter(p => p.el !== wordEl);
                                if (wordParticles.length > 0) {
                                    updateParticleTargets();
                                    if (!animationFrameId) simulationLoop(performance.now());
                                } else {
                                    wordsLayer.innerHTML = '<div class="concept-empty">Ï≤´ Î≤àÏß∏ Îã®Ïñ¥Î•º Í∏∞Îã§Î¶¨Í≥† ÏûàÏñ¥Ïöî</div>';
                                    if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                                }
                            }, 700);
                        }
                    });

                    wordsLayer.appendChild(wordEl);
                    
                    const isVertical = Math.random() < 0.35; // Boosted chance for vertical words
                    if (isVertical) {
                        wordEl.classList.add('concept-word-vertical');
                    }

                    const rect = wordEl.getBoundingClientRect();
                    particle = {
                        el: wordEl,
                        x: centerW,
                        y: centerH,
                        prevX: centerW,
                        prevY: centerH,
                        originX: centerW,
                        originY: centerH,
                        vx: 0,
                        vy: 0,
                        width: rect.width,
                        height: rect.height,
                        currentFontSize: initialFontSize,
                        targetFontSize: targetFontSize,
                        isVertical,
                        spiralIndex,
                        phase: 'intro',
                        spiralProgress: 0,
                        introDuration: INTRO_DURATION_BASE + Math.random() * INTRO_DURATION_VARIANCE,
                        introStart: null,
                        bornAt: now,
                        color: assignedColor
                    };
                    assignParticleTarget(particle, centerW, centerH, geometry, spiralIndex);

                    // Start at center and move to target position
                    particle.originX = centerW;
                    particle.originY = centerH;
                    particle.x = centerW;
                    particle.y = centerH;
                    particle.prevX = centerW;
                    particle.prevY = centerH;
                    wordEl.style.left = `${centerW}px`;
                    wordEl.style.top = `${centerH}px`;
                    wordParticles.push(particle);
                    const introParticles = wordParticles.filter(p => p.phase === 'intro');


                    requestAnimationFrame(() => {
                        wordEl.classList.add('concept-word-visible');
                        animateWordEntry(wordEl);
                    });
                }
                
                const weightRatio = weight / Math.max(...limited.map(item => item[1]));
                const isHero = weightRatio > 0.7;
                const isAccent = !isHero && weightRatio > 0.4;
                particle.el.classList.toggle('concept-word-hero', isHero);
                particle.el.classList.toggle('concept-word-accent', isAccent);
            });

            if (!animationFrameId && wordParticles.length > 0) {
                simulationLoop(performance.now());
            }

            // Update D3 simulation with new particles
            if (d3Simulation && wordParticles.length > 0) {
                d3Simulation.nodes(wordParticles);
                d3Simulation.alpha(0.15).restart();
            }
        }

        // --- Data Fetching & Control ---
        // No longer needed - using broadcast only

        function stopAllIntervals() {
            if (realtimeChannel) {
                supabase.removeChannel(realtimeChannel);
                realtimeChannel = null;
            }
            if (simulationInterval) clearInterval(simulationInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (d3Simulation) d3Simulation.stop();
            simulationInterval = null;
            animationFrameId = null;
            d3Simulation = null;
        }
        
        function resetDisplay() {
            console.log('resetDisplay called');
            stopAllIntervals();
            mockAnswers = [];
            wordParticles = [];
            hiddenWords = [];
            wordsLayer.innerHTML = '';
            conceptTotal.textContent = '0';
            stopTimer();
            conceptUpdated.textContent = '10:00';
        }

        function startRealtimeSimulation() {
            console.log('startRealtimeSimulation called');
            resetDisplay();
            let count = 0;
            const question = QUESTIONS[currentQuestionIndex];
            startTimer();

            function generateSingleMockAnswer(questionId, index) {
                const currentQuestion = QUESTIONS.find(q => q.id === questionId);
                let answer;

                if (currentQuestion && currentQuestion.type === 'text') {
                    answer = TEXT_ANSWERS[Math.floor(Math.random() * TEXT_ANSWERS.length)];
                } else {
                    answer = KEYWORDS[Math.floor(Math.random() * KEYWORDS.length)] || KEYWORDS[index % KEYWORDS.length];
                }

                return {
                    id: `${questionId}-${index}-${Date.now()}`,
                    question_id: questionId,
                    answer: answer,
                    answer_text: answer,
                    created_at: new Date().toISOString()
                };
            }

            simulationInterval = setInterval(() => {
                if (count >= 300) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    return;
                }
                const newAnswer = generateSingleMockAnswer(question.id, count);
                mockAnswers.unshift(newAnswer);
                const frequencyMap = extractWordInstances(mockAnswers);
                renderWords(frequencyMap);
                conceptTotal.textContent = mockAnswers.length;
                count++;
            }, 500);
            
            // Simulation loop is started by renderWords if words exist
        }

        async function startRealtimeSubscription() {
            console.log('startRealtimeSubscription called');
            stopAllIntervals();
            mockAnswers = [];
            wordParticles = [];
            hiddenWords = [];
            wordsLayer.innerHTML = '';
            conceptTotal.textContent = '0';
            stopTimer();
            conceptUpdated.textContent = '10:00';

            const question = QUESTIONS[currentQuestionIndex];
            if (!question) return;

            startTimer();

            // Load existing answers first
            console.log('üì• Loading existing answers from DB...');
            const { data: existingAnswers, error } = await supabase
                .from('answers')
                .select('*')
                .eq('question_id', question.id)
                .order('created_at', { ascending: false });

            if (error) {
                console.error('Error loading existing answers:', error);
            } else if (existingAnswers && existingAnswers.length > 0) {
                console.log(`‚úÖ Loaded ${existingAnswers.length} existing answers`);
                mockAnswers = existingAnswers.map(a => ({
                    id: a.id,
                    question_id: a.question_id,
                    answer: a.answer_text,
                    answer_text: a.answer_text,
                    created_at: a.created_at
                }));

                const frequencyMap = extractWordInstances(mockAnswers);
                renderWords(frequencyMap);
                conceptTotal.textContent = mockAnswers.length;
            } else {
                console.log('‚ÑπÔ∏è No existing answers found');
            }

            // Subscribe to DB changes (Realtime)
            console.log('üîå Subscribing to channel:', `answers-q${question.id}`);
            realtimeChannel = supabase
                .channel(`answers-q${question.id}`)
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'answers',
                    filter: `question_id=eq.${question.id}`
                }, (payload) => {
                    console.log('üî• New answer from DB:', payload);
                    console.log('Payload details:', {
                        id: payload.new.id,
                        question_id: payload.new.question_id,
                        answer_text: payload.new.answer_text,
                        created_at: payload.new.created_at
                    });

                    const newAnswer = {
                        id: payload.new.id,
                        question_id: payload.new.question_id,
                        answer: payload.new.answer_text,
                        answer_text: payload.new.answer_text,
                        created_at: payload.new.created_at
                    };

                    mockAnswers.unshift(newAnswer);
                    console.log('Total answers now:', mockAnswers.length);

                    const frequencyMap = extractWordInstances(mockAnswers);
                    console.log('Frequency map:', frequencyMap);

                    renderWords(frequencyMap);
                    conceptTotal.textContent = mockAnswers.length;
                })
                .subscribe((status) => {
                    console.log('Realtime subscription status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('‚úÖ Ready to receive answers!');
                    }
                });
        }

        // --- Event Listeners ---
        prevQuestionBtn.addEventListener('click', () => navigateToQuestion(currentQuestionIndex - 1));
        nextQuestionBtn.addEventListener('click', () => navigateToQuestion(currentQuestionIndex + 1));

        toggleMockBtn.addEventListener('click', () => {
            console.log('toggleMockBtn clicked. isMockMode before:', isMockMode);
            isMockMode = !isMockMode;
            toggleMockBtn.classList.toggle('active', isMockMode);
            console.log('toggleMockBtn clicked. isMockMode after:', isMockMode);
            navigateToQuestion(currentQuestionIndex, { force: true });
        });

        window.addEventListener('resize', () => {
            updateParticleTargets();
        });

        // --- Initial Load ---
        const initialQuestionIndex = Number(params.get('question')) ? QUESTIONS.findIndex(q => q.id === Number(params.get('question'))) : 0;
        navigateToQuestion(initialQuestionIndex !== -1 ? initialQuestionIndex : 0, { force: true });

        // Ï¥àÍ∏∞ Î≤ÑÌäº ÏÉÅÌÉú ÏÑ§Ï†ï
        if (isMockMode) {
            toggleMockBtn.classList.add('active');
        }
    </script>
</body>
</html>
