<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Polling - Keyword Canvas</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Temporarily removed supabase-config.js to isolate issues -->
    <!-- <script src="supabase-config.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
</head>
<body class="concept-body">
    <div class="concept-wrapper">
        <header class="concept-top">
            <div class="concept-title-nav">
                <button class="concept-nav-btn" id="prevQuestionBtn" aria-label="이전 질문">‹</button>
                <div class="concept-question-display">
                    <h2 id="conceptQuestion">질문 로딩 중...</h2>
                    <p class="concept-question-desc" id="questionCounter"></p>
                </div>
                <button class="concept-nav-btn" id="nextQuestionBtn" aria-label="다음 질문">›</button>
            </div>
        </header>

        <main class="concept-cloud">
            <div class="concept-words" id="conceptWords"></div>
        </main>

        <footer class="concept-bottom">
            <div class="concept-participation">
                <div class="concept-link">
                    <span>참여 링크</span>
                    <p id="conceptLink"></p>
                </div>
                <div id="conceptQrCode"></div>
            </div>
            <div class="concept-meta-controls">
                <div class="concept-meta">
                    <div>
                        <p class="concept-label">누적 답변</p>
                        <p class="concept-value" id="conceptTotal">0</p>
                    </div>
                    <div>
                        <p class="concept-label">업데이트</p>
                        <p class="concept-value" id="conceptUpdated">-</p>
                    </div>
                </div>
                <div class="concept-actions">
                    <button class="concept-action" id="toggleMock">모의</button>
                </div>
            </div>
        </footer>
    </div>

    <script>
        console.log('Script started executing'); // Very early log

        // --- Temporarily define QUESTIONS array for debugging ---
        const QUESTIONS = [
            { id: 1, question: "가장 좋아하는 계절은?", color: "#4CAF50" },
            { id: 2, question: "오늘의 기분은?", color: "#2196F3" },
            { id: 3, question: "가장 좋아하는 음식은?", color: "#FFC107" }
        ];

        // --- DOM Elements ---
        const conceptQuestion = document.getElementById('conceptQuestion');
        const questionCounter = document.getElementById('questionCounter');
        const wordsLayer = document.getElementById('conceptWords');
        const conceptTotal = document.getElementById('conceptTotal');
        const conceptUpdated = document.getElementById('conceptUpdated');
        const conceptLink = document.getElementById('conceptLink');
        const qrCodeContainer = document.getElementById('conceptQrCode');
        const toggleMockBtn = document.getElementById('toggleMock');
        const prevQuestionBtn = document.getElementById('prevQuestionBtn');
        const nextQuestionBtn = document.getElementById('nextQuestionBtn');

        // --- State ---
        const params = new URLSearchParams(window.location.search);
        let currentQuestionIndex = 0;
        let isMockMode = params.get('mock') === '1';
        let pollingInterval = null;
        let simulationInterval = null;
        let mockAnswers = [];
        let wordParticles = [];
        let qrCodeInstance = null;
        let animationFrameId = null;

        // --- Constants ---
        const KEYWORDS = ['연결', '성장', '도전', '몰입', '설렘', '공감', '협업', '집중', '영감', '감동', '시너지', '에너지', '환대', '몰두', '발견', '혁신', '팀워크', '지원', '아이디어', '탐험', '성찰', '축제', '유연함', '치열함', '여유', '흥미', '모험', '발표', '피드백', '브레인스토밍', 'collaboration', 'momentum', 'breakthrough', 'catalyst', 'insight', 'iteration', 'community', 'confidence', 'empathy', 'curiosity'];
        const PREFIXES = ['따뜻한', '깊은', '새로운', '반짝이는', '집중의', '장난기 있는', '강렬한', '잔잔한', '선명한'];
        const SUFFIXES = ['무드', '아이디어', '영감', '에너지', '발견', '시간', '순간', '대화', '시선'];
        const MAX_WORDS = 150;
        const MAX_PARTICLE_SPEED = 2.2;
        const MIN_SEPARATION = 28;

        function getCloudBounds() {
            const rect = wordsLayer.getBoundingClientRect();
            let width = rect.width;
            let height = rect.height;
            if (width > 10 && height > 10) {
                return { width, height };
            }
            const parentRect = wordsLayer.parentElement?.getBoundingClientRect();
            width = parentRect?.width || window.innerWidth;
            height = parentRect?.height || window.innerHeight;
            return { width, height };
        }

        const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));

        function getSpiralGeometry(width, height, wordCount = MAX_WORDS) {
            const maxRadius = Math.max(220, Math.min(width, height) / 2 - 20);
            const minRadius = Math.max(30, maxRadius * 0.15);
            const count = Math.max(1, wordCount);
            const ringCount = Math.min(10, Math.max(3, Math.ceil(count / 25)));
            const ringSpan = (maxRadius - minRadius) / Math.max(1, ringCount - 1);
            const rings = [];
            let startIndex = 0;
            for (let i = 0; i < ringCount; i++) {
                const radius = maxRadius - ringSpan * i;
                const circumference = 2 * Math.PI * Math.max(40, radius);
                const capacity = Math.max(8, Math.round(circumference / 70));
                rings.push({ radius, start: startIndex, end: startIndex + capacity });
                startIndex += capacity;
            }
            // Ensure total coverage
            if (startIndex < count) {
                const extra = count - startIndex;
                rings[rings.length - 1].end += extra;
            }
            return { rings, count };
        }

        function assignParticleTarget(particle, centerW, centerH, geometry, spiralIndex = 0) {
            const clampedIndex = Math.max(0, Math.min(spiralIndex, geometry.count - 1));
            const ring = geometry.rings.find(r => clampedIndex < r.end) || geometry.rings[geometry.rings.length - 1];
            const radius = ring.radius;
            const angle = clampedIndex * GOLDEN_ANGLE;
            const jitterAngle = angle + (Math.random() - 0.5) * 0.04;
            const jitterRadius = radius + (Math.random() - 0.5) * Math.max(6, radius * 0.02);
            particle.targetX = centerW + Math.cos(jitterAngle) * jitterRadius;
            particle.targetY = centerH + Math.sin(jitterAngle) * jitterRadius;
            particle.spiralIndex = clampedIndex;
            particle.ringRadius = radius;
        }

        function updateParticleTargets() {
            if (!wordParticles.length) return;
            const { width, height } = getCloudBounds();
            const centerW = width / 2;
            const centerH = height / 2;
            const geometry = getSpiralGeometry(width, height, wordParticles.length);
            wordParticles.forEach(p => assignParticleTarget(p, centerW, centerH, geometry, p.spiralIndex || 0));
        }

        // --- Core Functions ---
        function updateQuestionMeta(question) {
            conceptQuestion.textContent = question.question;
            document.documentElement.style.setProperty('--concept-accent', question.color || '#7c3aed');
            const answerUrl = new URL(window.location.href);
            answerUrl.pathname = answerUrl.pathname.replace(/[^/]+$/, 'answer.html');
            answerUrl.search = `?question=${question.id}`;
            answerUrl.hash = '';
            const urlString = answerUrl.toString();
            conceptLink.textContent = urlString;

            if (qrCodeInstance) {
                qrCodeInstance.clear();
                qrCodeInstance.makeCode(urlString);
            } else {
                qrCodeInstance = new QRCode(qrCodeContainer, { text: urlString, width: 96, height: 96, colorDark: "#0f172a", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H });
            }
        }
        
        function navigateToQuestion(index) {
            console.log('navigateToQuestion called with index:', index);
            const newIndex = Math.max(0, Math.min(QUESTIONS.length - 1, index));
            if (newIndex === currentQuestionIndex && wordParticles.length > 0) {
                console.log('navigateToQuestion: Same question, particles exist, returning.');
                return;
            }

            currentQuestionIndex = newIndex;
            const question = QUESTIONS[currentQuestionIndex];
            
            updateQuestionMeta(question);
            questionCounter.textContent = `${currentQuestionIndex + 1} / ${QUESTIONS.length}`;
            
            prevQuestionBtn.disabled = currentQuestionIndex === 0;
            nextQuestionBtn.disabled = currentQuestionIndex === QUESTIONS.length - 1;

            resetDisplay();
            if (isMockMode) startRealtimeSimulation();
            else startRealDataPolling();
        }

        function extractWordInstances(answers) {
            const frequency = new Map();
            answers.forEach(answer => {
                if (!answer.answer_text) return;
                const tokens = answer.answer_text.split(/[\s,.;!?"'()\[\]{}]+/).map(token => token.replace(/^[^0-9a-zA-Z가-힣]+|[^0-9a-zA-Z가-힣]+$/g, '').trim()).filter(token => token.length > 1);
                tokens.forEach(token => frequency.set(token, (frequency.get(token) || 0) + 1));
            });
            return frequency;
        }

        // --- Simulation Loop ---
        function simulationLoop() {
            const { width: containerWidth, height: containerHeight } = getCloudBounds();
            const centerW = containerWidth / 2;
            const centerH = containerHeight / 2;

            for (let j = 0; j < wordParticles.length; j++) {
                const p1 = wordParticles[j];
                for (let k = j + 1; k < wordParticles.length; k++) {
                    const p2 = wordParticles[k];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = Math.max(((p1.width + p2.width) / 2) * 1.05, MIN_SEPARATION);

                    if (distance < minDistance && distance > 0) {
                        const force = ((minDistance - distance) / minDistance) * 0.18;
                        const angle = Math.atan2(dy, dx);
                        const fx = Math.cos(angle) * force;
                        const fy = Math.sin(angle) * force;
                        p1.vx += fx;
                        p1.vy += fy;
                        p2.vx -= fx;
                        p2.vy -= fy;
                    }
                }
                const centerDx = p1.x - centerW;
                const centerDy = p1.y - centerH;
                p1.vx += centerDx * 0.00005; // Slow outward drift from center
                p1.vy += centerDy * 0.00005;
            }

            for (const p of wordParticles) {
                p.vx *= 0.9; // Gentle damping so motion eases out
                p.vy *= 0.9;

                if (p.targetX !== undefined && p.targetY !== undefined) {
                    const targetDx = p.targetX - p.x;
                    const targetDy = p.targetY - p.y;
                    p.vx += targetDx * 0.00025;
                    p.vy += targetDy * 0.00025;
                }

                const radialDx = p.x - centerW;
                const radialDy = p.y - centerH;
                const radialDist = Math.hypot(radialDx, radialDy) || 1;
                if (p.ringRadius) {
                    const radialError = p.ringRadius - radialDist;
                    const radialForce = radialError * 0.0006;
                    p.vx += (radialDx / radialDist) * radialForce;
                    p.vy += (radialDy / radialDist) * radialForce;
                }

                // Clamp velocity to prevent runaway movement
                if (p.vx > MAX_PARTICLE_SPEED) p.vx = MAX_PARTICLE_SPEED;
                else if (p.vx < -MAX_PARTICLE_SPEED) p.vx = -MAX_PARTICLE_SPEED;
                if (p.vy > MAX_PARTICLE_SPEED) p.vy = MAX_PARTICLE_SPEED;
                else if (p.vy < -MAX_PARTICLE_SPEED) p.vy = -MAX_PARTICLE_SPEED;

                p.x += p.vx;
                p.y += p.vy;

                const edgePadding = Math.min(containerWidth, containerHeight) * 0.1;
                if (p.x < edgePadding) {
                    p.x = edgePadding;
                    p.vx *= -0.25;
                } else if (p.x > containerWidth - edgePadding) {
                    p.x = containerWidth - edgePadding;
                    p.vx *= -0.25;
                }

                if (p.y < edgePadding) {
                    p.y = edgePadding;
                    p.vy *= -0.25;
                } else if (p.y > containerHeight - edgePadding) {
                    p.y = containerHeight - edgePadding;
                    p.vy *= -0.25;
                }

                // Animate font size
                const sizeDiff = p.targetFontSize - p.currentFontSize;
                if (Math.abs(sizeDiff) > 0.01) {
                    p.currentFontSize += sizeDiff * 0.1;
                    p.el.style.fontSize = `${p.currentFontSize.toFixed(2)}rem`;
                    const rect = p.el.getBoundingClientRect();
                    p.width = rect.width;
                    p.height = rect.height;
                }
                
                // Update position using left/top and translate(-50%, -50%)
                p.el.style.left = `${p.x}px`;
                p.el.style.top = `${p.y}px`;
                p.el.style.transform = 'translate(-50%, -50%)';
            }

            animationFrameId = requestAnimationFrame(simulationLoop);
        }

        function renderWords(frequencyMap) {
            console.log('renderWords called with frequencyMap:', frequencyMap);
            const existingParticles = new Map();
            wordParticles.forEach(p => existingParticles.set(p.el.textContent, p));

            if (frequencyMap.size === 0 && wordParticles.length === 0) {
                wordsLayer.innerHTML = '<div class="concept-empty">첫 번째 단어를 기다리고 있어요</div>';
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            } else if (frequencyMap.size > 0 && wordsLayer.querySelector('.concept-empty')) {
                wordsLayer.innerHTML = '';
            }

            const sortedWords = [...frequencyMap.entries()].sort((a, b) => b[1] - a[1]);
            const limited = sortedWords.slice(0, MAX_WORDS);
            const newWordTexts = new Set(limited.map(item => item[0]));
            
            wordParticles = wordParticles.filter(p => {
                if (!newWordTexts.has(p.el.textContent)) {
                    p.el.classList.add('concept-word-hidden');
                    setTimeout(() => p.el.remove(), 300);
                    return false;
                }
                return true;
            });

            const maxWeight = Math.max(...limited.map(item => item[1]));
            const palette = ['#ef4444', '#f97316', '#facc15', '#22c55e', '#14b8a6', '#0ea5e9', '#3b82f6', '#6366f1', '#a855f7', '#ec4899'];
            const { width: containerWidth, height: containerHeight } = getCloudBounds();
            const centerW = containerWidth / 2;
            const centerH = containerHeight / 2;
            const geometry = getSpiralGeometry(containerWidth, containerHeight, limited.length);

            limited.forEach(([text, weight], index) => {
                const weightRatio = weight / maxWeight;
                const targetFontSize = 0.8 + weightRatio * 1.2;
                const spiralIndex = index;

                let particle = existingParticles.get(text);
                if (particle) {
                    particle.targetFontSize = targetFontSize;
                    assignParticleTarget(particle, centerW, centerH, geometry, spiralIndex);
                } else {
                    const wordEl = document.createElement('span');
                    wordEl.className = 'concept-word';
                    wordEl.textContent = text;
                    wordEl.style.color = palette[index % palette.length];
                    wordEl.style.opacity = 1; // Instant appearance
                    
                    const initialFontSize = 0.8;
                    wordEl.style.fontSize = `${initialFontSize}rem`;
                    
                    // Click to delete
                    wordEl.addEventListener('click', () => {
                        wordEl.classList.add('concept-word-hidden');
                        setTimeout(() => {
                            wordEl.remove();
                            wordParticles = wordParticles.filter(p => p.el !== wordEl);
                            if (wordParticles.length > 0) {
                                wordParticles.forEach(p => { p.vx += (Math.random() - 0.5) * 5; p.vy += (Math.random() - 0.5) * 5; });
                                if (!animationFrameId) simulationLoop();
                            } else {
                                wordsLayer.innerHTML = '<div class="concept-empty">첫 번째 단어를 기다리고 있어요</div>';
                                if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                            }
                        }, 300);
                    });

                    wordsLayer.appendChild(wordEl);
                    
                    const isVertical = Math.random() < 0.35; // Boosted chance for vertical words
                    if (isVertical) {
                        wordEl.classList.add('concept-word-vertical');
                    }

                    const rect = wordEl.getBoundingClientRect();
                    const jitterRadius = 6;
                    const spawnAngle = Math.random() * Math.PI * 2;
                    const spawnRadius = Math.random() * jitterRadius;
                    const startX = centerW + Math.cos(spawnAngle) * spawnRadius;
                    const startY = centerH + Math.sin(spawnAngle) * spawnRadius;
                    const launchSpeed = 1.4 + Math.random() * 0.6;
                    particle = {
                        el: wordEl,
                        x: startX,
                        y: startY,
                        vx: 0,
                        vy: 0,
                        width: rect.width,
                        height: rect.height,
                        currentFontSize: initialFontSize,
                        targetFontSize: targetFontSize,
                        isVertical,
                        spiralIndex,
                        pendingLaunchSpeed: launchSpeed
                    };
                    assignParticleTarget(particle, centerW, centerH, geometry, spiralIndex);
                    const dirX = particle.targetX - startX;
                    const dirY = particle.targetY - startY;
                    const dirMag = Math.hypot(dirX, dirY) || 1;
                    particle.vx = (dirX / dirMag) * particle.pendingLaunchSpeed;
                    particle.vy = (dirY / dirMag) * particle.pendingLaunchSpeed;
                    delete particle.pendingLaunchSpeed;
                    wordParticles.push(particle);
                }
                
                const isHero = weightRatio > 0.7;
                const isAccent = !isHero && weightRatio > 0.4;
                particle.el.classList.toggle('concept-word-hero', isHero);
                particle.el.classList.toggle('concept-word-accent', isAccent);
            });

            if (!animationFrameId && wordParticles.length > 0) {
                simulationLoop();
            }
        }

        // --- Data Fetching & Control ---
        // Removed fetchRealAnswers as supabase-config.js is temporarily removed
        // async function fetchRealAnswers() { ... }

        function stopAllIntervals() {
            if (pollingInterval) clearInterval(pollingInterval);
            if (simulationInterval) clearInterval(simulationInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            pollingInterval = null;
            simulationInterval = null;
            animationFrameId = null;
        }
        
        function resetDisplay() {
            console.log('resetDisplay called');
            stopAllIntervals();
            mockAnswers = [];
            wordParticles = [];
            wordsLayer.innerHTML = '';
            conceptTotal.textContent = '0';
        }

        function startRealtimeSimulation() {
            console.log('startRealtimeSimulation called');
            resetDisplay();
            let count = 0;
            const question = QUESTIONS[currentQuestionIndex];
            
            function generateSingleMockAnswer(questionId, index) {
                const word = KEYWORDS[index % KEYWORDS.length];
                const prefix = PREFIXES[Math.floor(Math.random() * PREFIXES.length)];
                const suffix = SUFFIXES[Math.floor(Math.random() * SUFFIXES.length)];
                const mode = Math.random();
                const text = mode < 0.3 ? `${prefix} ${word}` : mode < 0.6 ? `${word} ${suffix}` : word;
                return { id: `${questionId}-${index}-${Date.now()}`, question_id: questionId, answer_text: text, created_at: new Date().toISOString() };
            }

            simulationInterval = setInterval(() => {
                if (count >= 300) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    return;
                }
                const newAnswer = generateSingleMockAnswer(question.id, count);
                mockAnswers.unshift(newAnswer);
                const frequencyMap = extractWordInstances(mockAnswers);
                renderWords(frequencyMap);
                conceptTotal.textContent = mockAnswers.length;
                conceptUpdated.textContent = new Date().toLocaleTimeString();
                count++;
            }, 500);
            
            // Simulation loop is started by renderWords if words exist
        }

        function startRealDataPolling() {
            console.log('startRealDataPolling called - currently disabled');
            resetDisplay();
            // fetchRealAnswers(); // Initial fetch - disabled
            // pollingInterval = setInterval(fetchRealAnswers, 2000); // disabled
        }

        // --- Event Listeners ---
        prevQuestionBtn.addEventListener('click', () => navigateToQuestion(currentQuestionIndex - 1));
        nextQuestionBtn.addEventListener('click', () => navigateToQuestion(currentQuestionIndex + 1));

        toggleMockBtn.addEventListener('click', () => {
            console.log('toggleMockBtn clicked. isMockMode before:', isMockMode);
            isMockMode = !isMockMode;
            toggleMockBtn.classList.toggle('active', isMockMode);
            console.log('toggleMockBtn clicked. isMockMode after:', isMockMode);
            navigateToQuestion(currentQuestionIndex);
        });

        window.addEventListener('resize', () => {
            updateParticleTargets();
        });

        // --- Initial Load ---
        const initialQuestionIndex = Number(params.get('question')) ? QUESTIONS.findIndex(q => q.id === Number(params.get('question'))) : 0;
        navigateToQuestion(initialQuestionIndex !== -1 ? initialQuestionIndex : 0);
        
        if (isMockMode) {
            toggleMockBtn.classList.add('active');
        }
    </script>
</body>
</html>
