<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Polling - Mutalisk (No Overlap Demo)</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/motion@11.11.13/dist/motion.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body class="concept-body concept-display">
    <div class="concept-wrapper">
        <header class="concept-top">
            <div class="concept-title-nav">
                <div class="concept-question-display">
                    <h2 id="conceptQuestion">ÏßàÎ¨∏ Î°úÎî© Ï§ë...</h2>
                </div>
            </div>
        </header>

        <main class="concept-cloud">
            <div class="concept-decorations">
                <div class="concept-decoration star" style="top: 10%; left: 15%; animation-delay: 0s;"></div>
                <div class="concept-decoration circle" style="top: 20%; left: 80%; animation-delay: 2s;"></div>
                <div class="concept-decoration bubble" style="top: 70%; left: 25%; animation-delay: 1s;"></div>
                <div class="concept-decoration star" style="top: 85%; left: 70%; animation-delay: 3s;"></div>
                <div class="concept-decoration circle" style="top: 40%; left: 10%; animation-delay: 1.5s;"></div>
                <div class="concept-decoration bubble" style="top: 60%; left: 90%; animation-delay: 2.5s;"></div>
                <div class="concept-decoration star" style="top: 30%; left: 50%; animation-delay: 0.5s;"></div>
                <div class="concept-decoration circle" style="top: 15%; left: 60%; animation-delay: 3.5s;"></div>
                <div class="concept-decoration bubble" style="top: 80%; left: 40%; animation-delay: 1.8s;"></div>
                <div class="concept-decoration star" style="top: 50%; left: 85%; animation-delay: 2.2s;"></div>
            </div>
            <div class="concept-words" id="conceptWords"></div>
            <div class="concept-overlay concept-overlay-bottom-left">
                <div class="concept-qr-card">
                    <div class="concept-qr-box" id="conceptQrCode"></div>
                </div>
            </div>
            <div class="concept-overlay concept-overlay-bottom-right">
                <div class="concept-stats-card">
                    <div>
                        <p class="concept-label">ÎàÑÏ†Å ÎãµÎ≥Ä</p>
                        <p class="concept-value" id="conceptTotal">0</p>
                    </div>
                    <div class="concept-timer-row">
                        <div>
                            <p class="concept-label">ÌÉÄÏù¥Î®∏</p>
                            <p class="concept-value" id="conceptUpdated">10:00</p>
                        </div>
                        <button class="concept-action concept-action-ghost" id="toggleMock">Î™®Ïùò</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        console.log('Script started executing'); // Very early log

        // Questions loaded from supabase-config.js

        // Public URL for QR code (GitHub Pages)
        const PUBLIC_URL = 'https://chosundeveloper.github.io/live-polling';

        // Timer state
        let questionStartTime = null;

        // --- DOM Elements ---
        const conceptQuestion = document.getElementById('conceptQuestion');
        const wordsLayer = document.getElementById('conceptWords');
        const conceptTotal = document.getElementById('conceptTotal');
        const conceptUpdated = document.getElementById('conceptUpdated');
        const qrCodeContainer = document.getElementById('conceptQrCode');
        const toggleMockBtn = document.getElementById('toggleMock');

        // --- State ---
        const params = new URLSearchParams(window.location.search);
        let currentQuestionIndex = 0;
        let isMockMode = params.get('mock') === '1';
        let realtimeChannel = null;
        let simulationInterval = null;
        let mockAnswers = [];
        let displayAnswers = [];
        let wordParticles = [];
        let hiddenWords = [];
        let pendingParticleQueue = [];
        let pendingParticleKeys = new Set();
        let qrCodeInstance = null;
        let animationFrameId = null;
        let timerInterval = null;
        let timerDeadline = null;
        let sessionStartTime = null; // ÌéòÏù¥ÏßÄ Î°úÎìú ÏãúÏ†ê
        let spawnTimeoutId = null;

        // --- Constants ---
        const KEYWORDS = ['Í∞êÏÇ¨', 'Í∏∞ÏÅ®', 'ÌèâÏïà', 'ÏùÄÌòú', 'ÌöåÍ∞ú', 'Ï∞¨Ïñë', 'Í≤ΩÎ∞∞', 'ÏÇ¨Îûë', 'ÏÜåÎßù', 'ÎØøÏùå', 'Í≤∏ÏÜê', 'ÏàúÏ¢Ö', 'Í∞êÍ≤©', 'Í∏∞ÎåÄ', 'Ï∂ïÎ≥µ', 'ÌöåÎ≥µ', 'ÏπòÏú†', 'ÏÉàÌûò', 'Í∞êÎèô', 'Í∏∞ÎèÑ', 'Í∞ÑÏ†àÌï®', 'Îú®Í±∞ÏõÄ', 'Ï∂©Îßå', 'ÌèâÏò®', 'Í∏∞Îã§Î¶º', 'Í∞àÎßù', 'Í∞ÑÍµ¨', 'Í≥†Î∞±', 'ÌóåÏã†'];
        const PREFIXES = ['Îî∞ÎúªÌïú', 'ÍπäÏùÄ', 'ÏÉàÎ°úÏö¥', 'Îú®Í±∞Ïö¥', 'Í∞ÑÏ†àÌïú', 'Í≤∏ÏÜêÌïú', 'ÏßÑÏã§Ìïú', 'ÏûîÏûîÌïú', 'Ï∂©ÎßåÌïú'];
        const SUFFIXES = ['ÎßàÏùå', 'Í∞êÏÇ¨', 'ÏùÄÌòú', 'Í∏∞ÏÅ®', 'ÌèâÏïà', 'ÏÜåÎßù', 'ÎØøÏùå', 'ÏÇ¨Îûë', 'Ï∞¨Ïñë'];
        const TEXT_ANSWERS = [
            'Í∞êÏÇ¨',
            'Í∏∞ÏÅ®',
            'ÌèâÏïà',
            'ÏùÄÌòú',
            'ÌöåÍ∞ú',
            'Ï∞¨Ïñë',
            'Í≤ΩÎ∞∞',
            'ÏÇ¨Îûë',
            'ÏÜåÎßù',
            'ÎØøÏùå',
            'Í≤∏ÏÜê',
            'ÏàúÏ¢Ö',
            'Í∞êÍ≤©',
            'Í∏∞ÎåÄ',
            'Ï∂ïÎ≥µ',
            'ÌöåÎ≥µ',
            'ÏπòÏú†',
            'ÏÉàÌûò',
            'Í∞êÎèô',
            'Í∏∞ÎèÑ',
            'Í∞ÑÏ†àÌï®',
            'Îú®Í±∞ÏõÄ',
            'Ï∂©Îßå',
            'ÌèâÏò®',
            'Í∏∞Îã§Î¶º',
            'Í∞àÎßù',
            'Í∞ÑÍµ¨',
            'Í≥†Î∞±',
            'ÌóåÏã†',
            'Í∞êÏÇ¨ÌïúÎßàÏùå',
            'Í∏∞ÏÅúÎßàÏùå',
            'ÌèâÏïàÌï®',
            'ÏùÄÌòúÎ°úÏõÄ',
            'Í∞êÏÇ¨ÏôÄÍ∏∞ÏÅ®',
            'ÏÇ¨ÎûëÍ≥ºÌèâÏïà'
        ];
        const MAX_WORDS = 150;
        const FIXED_FONT_SIZE = 25; // Fixed font size for all words
        const MAX_PARTICLE_SPEED = 0.001;
        const MIN_SEPARATION = 80; // Minimum pixel gap between words
        const DEFAULT_PARTICLE_WIDTH = 48;
        const DEFAULT_PARTICLE_HEIGHT = 22;
        const INTRO_DURATION_BASE = 180000; // extremely slow duration (3 minutes)
        const INTRO_DURATION_VARIANCE = 20000;
        const INTRO_BLOOM_JITTER = 0; // No bloom
        const INTRO_SPIRAL_TWIST = 0; // No spiral
        const INTRO_SWAY_AMPLITUDE = 0; // No sway
        const INTRO_SWAY_FREQUENCY = 1.1;
        const INTRO_STAGE_MIN_RADIUS = 10;
        const INTRO_STAGE_MAX_RADIUS = 40;
        const INTRO_CLUSTER_RATIO = 0.3; // 30% for gathering, 70% for spreading (slower spread)
        const INTRO_CLUSTER_SWAY = 0;
        const INTRO_CLUSTER_PADDING = 120;
        const OUTWARD_DRIFT_FORCE = 0.000002;
        const TARGET_ATTRACTION_FORCE = 0.000001;
        const RADIAL_FORCE = 0.000004;
        const MIN_WORD_LIFETIME = 7000;
        const TIMER_DURATION_MS = 600 * 1000; // 600 seconds (10 minutes)
        const COLOR_PALETTE = ['#5e4fa2', '#3288bd', '#66c2a5', '#abdda4', '#e6f598', '#fee08b', '#fdae61', '#f46d43', '#d53e4f', '#9e0142'];
        // Exclude yellow (#e6f598 index 4), lime green (#abdda4 index 3), light orange (#fee08b index 5), orange (#fdae61 index 6), and dark red (#9e0142 index 9)
        const EXCLUDED_COLOR_INDICES = [3, 4, 5, 6, 9];
        const MAX_CELL_SPREAD_RATIO = 0.38; // Expanded for much more space
        const INNER_CORE_RATIO = 0.06; // Inner core that stays stable (very small)
        const PUSH_THRESHOLD_RATIO = 0.10; // Start pushing outward very early
        const TETRIS_COLS = 6;
        const TETRIS_ROWS = 24;
        const TETRIS_BASE_FALL_SPEED = 180;
        const TETRIS_SPEED_VARIANCE = 60;
        const TETRIS_CELL_WIDTH_MIN = 140;
        const TETRIS_CELL_WIDTH_MAX = 220;
        const TETRIS_CELL_HEIGHT_MIN = 80;
        const TETRIS_CELL_HEIGHT_MAX = 120;
        const MOCK_WORD_POOL = buildMockWordPool();
        let mockWordQueue = shuffleArray([...MOCK_WORD_POOL]);
        let mockWordIndex = 0;
        let gridMetrics = {
            cols: TETRIS_COLS,
            rows: TETRIS_ROWS,
            cellWidth: 120,
            cellHeight: 52,
            offsetX: 0,
            offsetY: 0,
            width: 0,
            height: 0
        };
        let tetrisGrid = createEmptyGrid();
        let lastFrameTime = null;
        const DROP_QUEUE_DELAY_BASE = 450;
        const DROP_QUEUE_DELAY_VARIANCE = 350;

        function buildMockWordPool() {
            const uniqueWords = new Set();
            TEXT_ANSWERS.forEach(word => uniqueWords.add(word));
            KEYWORDS.forEach(word => uniqueWords.add(word));

            KEYWORDS.forEach(keyword => {
                PREFIXES.forEach(prefix => {
                    uniqueWords.add(`${prefix} ${keyword}`);
                    SUFFIXES.forEach(suffix => {
                        uniqueWords.add(`${prefix} ${keyword} ${suffix}`);
                    });
                });
                SUFFIXES.forEach(suffix => {
                    uniqueWords.add(`${keyword} ${suffix}`);
                });
            });

            return Array.from(uniqueWords);
        }

        function shuffleArray(array) {
            const result = [...array];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        function getNextMockWord() {
            if (!mockWordQueue.length) {
                mockWordQueue = shuffleArray([...MOCK_WORD_POOL]);
                mockWordIndex = 0;
            }
            if (mockWordIndex >= mockWordQueue.length) {
                mockWordQueue = shuffleArray([...MOCK_WORD_POOL]);
                mockWordIndex = 0;
            }
            return mockWordQueue[mockWordIndex++];
        }

        function selectWordColor(weightRatio, index) {
            // Select random color, excluding poorly visible ones
            // 50% chance for blue (#3288bd index 1), 50% for other allowed colors
            if (Math.random() < 0.5) {
                return COLOR_PALETTE[1]; // Blue
            }

            let colorIndex;
            do {
                colorIndex = Math.floor(Math.random() * COLOR_PALETTE.length);
            } while (EXCLUDED_COLOR_INDICES.includes(colorIndex));
            return COLOR_PALETTE[colorIndex];
        }
        window.selectWordColor = selectWordColor;

        function splitWordIntoCharacters(wordEl) {
            if (!wordEl || wordEl.dataset.charsSplit === '1') {
                return wordEl?.querySelectorAll('.concept-char');
            }
            const text = wordEl.textContent;
            const isVertical = wordEl.classList.contains('concept-word-vertical');

            wordEl.textContent = '';
            const fragment = document.createDocumentFragment();

            if (isVertical) {
                // For vertical text: keep entire text as one block with spaces
                const textSpan = document.createElement('span');
                textSpan.className = 'concept-char concept-word-block';
                textSpan.textContent = text;
                fragment.appendChild(textSpan);
            } else {
                // For horizontal text: keep entire text as one block, don't split
                const textSpan = document.createElement('span');
                textSpan.className = 'concept-char concept-word-block';
                textSpan.textContent = text;
                fragment.appendChild(textSpan);
            }

            wordEl.appendChild(fragment);
            wordEl.dataset.charsSplit = '1';
            return wordEl.querySelectorAll('.concept-char');
        }

        function animateWordEntry(wordEl) {
            console.log('üé¨ animateWordEntry called for:', wordEl.textContent);
            if (!wordEl) {
                console.log('‚ùå No wordEl');
                return;
            }

            const initialSize = FIXED_FONT_SIZE * 2.5;
            const finalSize = FIXED_FONT_SIZE;
            console.log(`üìè Setting up fontSize animation from ${initialSize}px to ${finalSize}px`);

            // Set initial large size with CSS
            wordEl.style.fontSize = `${initialSize}px`;
            wordEl.style.transition = 'none';
            console.log('‚úÖ Initial fontSize set:', wordEl.style.fontSize);

            // Force reflow
            wordEl.offsetHeight;

            // Start animation after a small delay
            requestAnimationFrame(() => {
                wordEl.style.transition = 'font-size 1.2s cubic-bezier(0.34, 1.56, 0.64, 1)';
                wordEl.style.fontSize = `${finalSize}px`;
                console.log('üé¨ Animation started');
            });

            // Try motion.js if available
            if (window.motion) {
                const chars = splitWordIntoCharacters(wordEl);
                if (chars && chars.length > 0) {
                    const isVertical = wordEl.classList.contains('concept-word-vertical');
                    const { animate, stagger, spring } = window.motion;
                    const letterSpring = spring({ stiffness: 85, damping: 26, mass: 1.0 });

                    animate(chars, {
                        opacity: [0, 1],
                        y: [isVertical ? 18 : 32, 0],
                        x: [isVertical ? -12 : 0, 0],
                        rotateX: [isVertical ? 0 : -24, 0],
                        skewY: [isVertical ? -6 : 0, 0]
                    }, {
                        easing: letterSpring,
                        duration: 1.35,
                        delay: stagger(0.018)
                    });
                }
            }
        }

        function getCloudBounds() {
            const rect = wordsLayer.getBoundingClientRect();
            let width = rect.width;
            let height = rect.height;
            if (width > 10 && height > 10) {
                return { width, height };
            }
            const parentRect = wordsLayer.parentElement?.getBoundingClientRect();
            width = parentRect?.width || window.innerWidth;
            height = parentRect?.height || window.innerHeight;
            return { width, height };
        }

        const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));



        function findClusterPosition(existing, centerW, centerH, baseRadius, baseAngle) {
            if (!existing.length) {
                const x = centerW + Math.cos(baseAngle) * baseRadius;
                const y = centerH + Math.sin(baseAngle) * baseRadius;
                return { x, y };
            }

            let best = null;
            let bestScore = -Infinity;
            for (let attempt = 0; attempt < 500; attempt++) {
                const angle = baseAngle + attempt * (GOLDEN_ANGLE * 0.25) + (Math.random() - 0.5) * 0.25;
                const radius = baseRadius + attempt * 1;
                const x = centerW + Math.cos(angle) * radius;
                const y = centerH + Math.sin(angle) * radius;
                let minDist = Infinity;
                for (const p of existing) {
                    const dx = x - p.x;
                    const dy = y - p.y;
                    const dist = Math.hypot(dx, dy);
                    const needed = ((p.width || DEFAULT_PARTICLE_WIDTH) / 2) + INTRO_CLUSTER_PADDING;
                    if (dist < needed) {
                        minDist = dist - needed;
                        break;
                    }
                    minDist = Math.min(minDist, dist - needed);
                }
                if (minDist >= INTRO_CLUSTER_PADDING) {
                    return { x, y };
                }
                if (minDist > bestScore) {
                    bestScore = minDist;
                    best = { x, y };
                }
            }
            return best || { x: centerW + Math.cos(baseAngle) * baseRadius, y: centerH + Math.sin(baseAngle) * baseRadius };
        }

        function getSpiralGeometry(width, height, wordCount = MAX_WORDS) {
            const usableRadius = Math.min(width, height) * MAX_CELL_SPREAD_RATIO;
            const maxRadius = usableRadius * 0.95; // Slightly smaller to stay within bounds
            const minRadius = Math.max(25, maxRadius * 0.12);
            const count = Math.max(1, wordCount);
            const ringCount = Math.min(10, Math.max(3, Math.ceil(count / 25)));
            const ringSpan = (maxRadius - minRadius) / Math.max(1, ringCount - 1);
            const rings = [];
            let startIndex = 0;
            // Fill from outside to inside: start with maxRadius
            for (let i = 0; i < ringCount; i++) {
                const radius = maxRadius - ringSpan * i;
                const circumference = 2 * Math.PI * Math.max(40, radius);
                const capacity = Math.max(8, Math.round(circumference / 70));
                rings.push({ radius, start: startIndex, end: startIndex + capacity });
                startIndex += capacity;
            }
            // Ensure total coverage
            if (startIndex < count) {
                const extra = count - startIndex;
                rings[rings.length - 1].end += extra;
            }
            return { rings, count };
        }

        function assignParticleTarget(particle, centerW, centerH, geometry, spiralIndex = 0) {
            const clampedIndex = Math.max(0, Math.min(spiralIndex, geometry.count - 1));
            const ring = geometry.rings.find(r => clampedIndex < r.end) || geometry.rings[geometry.rings.length - 1];
            const radius = ring.radius;
            const angle = clampedIndex * GOLDEN_ANGLE;
            const jitterAngle = angle + (Math.random() - 0.5) * 0.04;
            const jitterRadius = radius + (Math.random() - 0.5) * Math.max(6, radius * 0.02);
            particle.targetX = centerW + Math.cos(jitterAngle) * jitterRadius;
            particle.targetY = centerH + Math.sin(jitterAngle) * jitterRadius;
            particle.spiralIndex = clampedIndex;
            particle.ringRadius = radius;
            particle.ringAngle = jitterAngle;
        }

        function getParticleDimensions(particle) {
            // Always get fresh dimensions from DOM
            const rect = particle.el.getBoundingClientRect();
            const width = rect.width || DEFAULT_PARTICLE_WIDTH;
            const height = rect.height || DEFAULT_PARTICLE_HEIGHT;
            particle.width = width;
            particle.height = height;
            return { width, height };
        }

        function createEmptyGrid() {
            return Array.from({ length: TETRIS_ROWS }, () => Array(TETRIS_COLS).fill(null));
        }

        function resetDropQueue() {
            pendingParticleQueue = [];
            pendingParticleKeys.clear();
            if (spawnTimeoutId) {
                clearTimeout(spawnTimeoutId);
                spawnTimeoutId = null;
            }
        }

        function prunePendingQueue(validKeys = null) {
            if (!pendingParticleQueue.length) return;
            pendingParticleQueue = pendingParticleQueue.filter(entry => {
                const keep = !validKeys || validKeys.has(entry.key);
                if (!keep) {
                    pendingParticleKeys.delete(entry.key);
                }
                return keep;
            });
            if (!pendingParticleQueue.length && spawnTimeoutId) {
                clearTimeout(spawnTimeoutId);
                spawnTimeoutId = null;
            }
        }

        function enqueueParticleCreation(entry) {
            if (!entry || pendingParticleKeys.has(entry.key)) return;
            pendingParticleQueue.push(entry);
            pendingParticleKeys.add(entry.key);
            processPendingParticles();
        }

        function processPendingParticles() {
            if (!pendingParticleQueue.length) return;
            if (wordParticles.some(p => p.state === 'falling')) return;
            if (spawnTimeoutId) return;
            const delay = DROP_QUEUE_DELAY_BASE + Math.random() * DROP_QUEUE_DELAY_VARIANCE;
            spawnTimeoutId = setTimeout(() => {
                spawnTimeoutId = null;
                if (!pendingParticleQueue.length) {
                    processPendingParticles();
                    return;
                }
                const next = pendingParticleQueue.shift();
                if (!next) {
                    processPendingParticles();
                    return;
                }
                pendingParticleKeys.delete(next.key);
                const newParticle = createTetrisParticle(next.key, next.data, next.maxWeightSnapshot, next.index);
                wordParticles.push(newParticle);
                ensureAnimationLoop();
            }, delay);
        }

        function removePendingByText(text) {
            if (!text || !pendingParticleQueue.length) return;
            pendingParticleQueue = pendingParticleQueue.filter(entry => {
                if (entry.data?.text === text) {
                    pendingParticleKeys.delete(entry.key);
                    return false;
                }
                return true;
            });
            if (!pendingParticleQueue.length && spawnTimeoutId) {
                clearTimeout(spawnTimeoutId);
                spawnTimeoutId = null;
            }
        }

        function updateGridMetrics(wordCount = MAX_WORDS) {
            const { width, height } = getCloudBounds();
            gridMetrics.width = width;
            gridMetrics.height = height;
            gridMetrics.cols = TETRIS_COLS;
            gridMetrics.rows = TETRIS_ROWS;
            const tentativeWidth = width / gridMetrics.cols;
            if (tentativeWidth >= TETRIS_CELL_WIDTH_MIN) {
                gridMetrics.cellWidth = Math.min(TETRIS_CELL_WIDTH_MAX, Math.max(TETRIS_CELL_WIDTH_MIN, tentativeWidth));
            } else {
                gridMetrics.cellWidth = tentativeWidth;
            }
            const totalGridWidth = gridMetrics.cellWidth * gridMetrics.cols;
            gridMetrics.offsetX = Math.max(gridMetrics.cellWidth / 2, (width - totalGridWidth) / 2 + gridMetrics.cellWidth / 2);
            let cellHeight = height / gridMetrics.rows;
            if (cellHeight >= TETRIS_CELL_HEIGHT_MIN) {
                cellHeight = Math.min(TETRIS_CELL_HEIGHT_MAX, Math.max(TETRIS_CELL_HEIGHT_MIN, cellHeight));
            }
            const totalGridHeight = cellHeight * gridMetrics.rows;
            if (totalGridHeight > height) {
                cellHeight = height / gridMetrics.rows;
            }
            gridMetrics.cellHeight = Math.max(24, cellHeight);
            gridMetrics.offsetY = gridMetrics.cellHeight / 2;
        }

        function getCellCenter(col, row) {
            return {
                x: gridMetrics.offsetX + col * gridMetrics.cellWidth,
                y: gridMetrics.offsetY + row * gridMetrics.cellHeight
            };
        }

        function pickSpawnColumn() {
            const heights = [];
            for (let col = 0; col < gridMetrics.cols; col++) {
                let height = 0;
                for (let row = 0; row < gridMetrics.rows; row++) {
                    if (tetrisGrid[row][col]) {
                        height = gridMetrics.rows - row;
                        break;
                    }
                }
                heights.push(height);
            }
            const minHeight = Math.min(...heights);
            const candidates = heights
                .map((h, idx) => (h === minHeight ? idx : null))
                .filter(idx => idx !== null);
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        function updateWordDimensions(particle) {
            if (!particle || !particle.el) return;
            const horizontalPadding = 48;
            particle.el.style.maxWidth = `${Math.max(60, gridMetrics.cellWidth - horizontalPadding)}px`;
            particle.el.style.whiteSpace = 'nowrap';
            particle.el.style.textAlign = 'center';
            particle.el.style.padding = '14px 26px';
        }

        function updateDomPosition(particle) {
            if (!particle || !particle.el) return;
            particle.el.style.left = `${particle.x}px`;
            particle.el.style.top = `${particle.y}px`;
        }

        function removeParticle(particle, options = {}) {
            if (!particle) return;
            let released = false;
            if (particle.row !== null && tetrisGrid[particle.row] && tetrisGrid[particle.row][particle.col] === particle) {
                tetrisGrid[particle.row][particle.col] = null;
                released = true;
            }
            particle.state = 'removed';
            if (particle.el) {
                particle.el.classList.remove('concept-word-visible');
                particle.el.classList.add('concept-word-hidden');
                const delay = options.immediate ? 0 : 450;
                setTimeout(() => {
                    particle.el?.remove();
                }, delay);
            }
            if (released) {
                releaseUnsupportedWords();
                ensureAnimationLoop();
                processPendingParticles();
            }
        }

        function lockParticle(particle, targetRow) {
            if (!particle || !particle.el) return;
            const clampedRow = Math.min(Math.max(targetRow, 0), gridMetrics.rows - 1);
            const { x, y } = getCellCenter(particle.col, clampedRow);
            particle.x = x;
            particle.y = y;
            particle.row = clampedRow;
            particle.state = 'locked';
            updateDomPosition(particle);
            tetrisGrid[clampedRow][particle.col] = particle;
            particle.el.style.transition = 'left 160ms ease, top 160ms ease';
            setTimeout(() => {
                if (particle.el) {
                    particle.el.style.transition = '';
                }
            }, 200);
            checkCompletedRows();
            setTimeout(() => {
                processPendingParticles();
            }, 120);
        }

        function removeAnswerFromDisplay(answerRef) {
            if (!answerRef) return;
            const index = displayAnswers.indexOf(answerRef);
            if (index !== -1) {
                displayAnswers.splice(index, 1);
            }
        }

        function clearRow(row) {
            for (let col = 0; col < gridMetrics.cols; col++) {
                const particle = tetrisGrid[row][col];
                if (!particle) continue;
                tetrisGrid[row][col] = null;
                removeAnswerFromDisplay(particle.answerRef);
                removeParticle(particle);
                wordParticles = wordParticles.filter(p => p !== particle);
            }
        }

        function releaseUnsupportedWords() {
            for (let row = gridMetrics.rows - 2; row >= 0; row--) {
                for (let col = 0; col < gridMetrics.cols; col++) {
                    const particle = tetrisGrid[row][col];
                    if (!particle) continue;
                    const below = tetrisGrid[row + 1][col];
                    if (!below) {
                        tetrisGrid[row][col] = null;
                        particle.row = null;
                        particle.state = 'falling';
                    }
                }
            }
        }

        function checkCompletedRows() {
            // Ï§ÑÏù¥ Í∞ÄÎìù Ï∞®ÎèÑ Ï†úÍ±∞ÌïòÏßÄ ÏïäÍ≥† Í≥ÑÏÜç ÏåìÏù¥ÎèÑÎ°ù Ïú†ÏßÄ
            return;
        }

        function createTetrisParticle(key, data, maxWeight, index) {
            const { text, weight } = data;
            const wordEl = document.createElement('span');
            wordEl.className = 'concept-word';
            const isVertical = Math.random() < 0.2;
            if (isVertical) {
                wordEl.classList.add('concept-word-vertical');
            }
            wordEl.textContent = text;
            wordEl.dataset.wordKey = key;
            const assignedColor = selectWordColor(weight / (maxWeight || 1), index);
            wordEl.style.color = assignedColor;
            wordEl.style.fontSize = `${FIXED_FONT_SIZE}px`;
            updateWordDimensions({ el: wordEl });
            wordsLayer.appendChild(wordEl);

            const spawnCol = pickSpawnColumn();
            const spawnY = gridMetrics.offsetY - gridMetrics.cellHeight * 2;
            const { x } = getCellCenter(spawnCol, 0);

            const particleData = {
                key,
                el: wordEl,
                col: spawnCol,
                row: null,
                x,
                y: spawnY,
                state: 'falling',
                fallSpeed: TETRIS_BASE_FALL_SPEED + (Math.random() - 0.5) * TETRIS_SPEED_VARIANCE,
                answerRef: data.answerRef,
                weight,
                color: assignedColor,
                bornAt: performance.now()
            };

            updateWordDimensions(particleData);
            updateDomPosition(particleData);

            wordEl.addEventListener('click', () => {
                hiddenWords.push(text);
                removePendingByText(text);
                removeParticle(particleData);
                wordParticles = wordParticles.filter(p => p !== particleData);
            });

            requestAnimationFrame(() => {
                wordEl.classList.add('concept-word-visible');
                animateWordEntry(wordEl);
            });

            const weightRatio = maxWeight > 0 ? weight / maxWeight : 0;
            const isHero = weightRatio > 0.7;
            const isAccent = !isHero && weightRatio > 0.4;
            wordEl.classList.toggle('concept-word-hero', isHero);
            wordEl.classList.toggle('concept-word-accent', isAccent);

            return particleData;
        }

        function updateFallingParticle(particle, delta) {
            if (!particle || particle.state !== 'falling') return;
            const speed = particle.fallSpeed || TETRIS_BASE_FALL_SPEED;
            const newY = particle.y + speed * delta;
            const bottomEdge = newY + gridMetrics.cellHeight / 2;
            const relative = bottomEdge - gridMetrics.offsetY;
            let targetRow = Math.floor(relative / gridMetrics.cellHeight);
            if (targetRow >= gridMetrics.rows) {
                lockParticle(particle, gridMetrics.rows - 1);
                return;
            }
            if (targetRow >= 0 && tetrisGrid[targetRow][particle.col]) {
                lockParticle(particle, targetRow - 1);
                return;
            }
            particle.y = newY;
            updateDomPosition(particle);
        }

        function ensureAnimationLoop() {
            if (animationFrameId) return;
            if (!wordParticles.some(p => p.state === 'falling')) return;
            animationFrameId = requestAnimationFrame(simulationLoop);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimerDisplay() {
            if (!timerDeadline) {
                conceptUpdated.textContent = '10:00';
                return;
            }
            const remaining = Math.max(0, timerDeadline - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = String(Math.floor((remaining % 60000) / 1000)).padStart(2, '0');
            conceptUpdated.textContent = `${minutes}:${seconds}`;
            if (remaining <= 0) {
                stopTimer();
            }
        }

        function startTimer() {
            stopTimer();
            timerDeadline = Date.now() + TIMER_DURATION_MS;
            updateTimerDisplay();
            timerInterval = setInterval(updateTimerDisplay, 1000);
        }

        function updateIntroMotion(particle, centerW, centerH, timestamp) {
            if (particle.phase !== 'intro') return false;
            if (!particle.introStart) {
                particle.introStart = timestamp;
            }
            const duration = particle.introDuration || INTRO_DURATION_BASE;
            const rawProgress = duration <= 0 ? 1 : Math.min(1, (timestamp - particle.introStart) / duration);

            let targetX, targetY;

            // Move from center toward target position (outward)
            targetX = particle.originX + (particle.targetX - particle.originX) * rawProgress;
            targetY = particle.originY + (particle.targetY - particle.originY) * rawProgress;

            // Calculate force to move towards targetX, targetY at MAX_PARTICLE_SPEED
            const dx = targetX - particle.x;
            const dy = targetY - particle.y;
            const dist = Math.hypot(dx, dy);

            if (dist > 0.000001) { // Apply force if not already at target
                const forceMagnitude = dist * 0.005; // A small force to guide it
                particle.forceX += (dx / dist) * forceMagnitude;
                particle.forceY += (dy / dist) * forceMagnitude;
            }

            if (rawProgress >= 1) {
                particle.x = particle.targetX;
                particle.y = particle.targetY;
                particle.vx = 0;
                particle.vy = 0;
                particle.prevX = particle.targetX;
                particle.prevY = particle.targetY;
                particle.phase = 'idle';
                particle.introStart = null;
                particle.introDuration = null;
                return false;
            }
            return true;
        }

        // --- Core Functions ---
        function updateQuestionMeta(question) {
            conceptQuestion.textContent = question.question;
            document.documentElement.style.setProperty('--concept-accent', question.color || '#7c3aed');

            // Set question start time for timer sync
            questionStartTime = Date.now();
            timerDeadline = questionStartTime + TIMER_DURATION_MS;

            // Pass START TIME (not deadline) so timer syncs correctly
            const urlString = `${PUBLIC_URL}/answer.html?q=${question.id}&startTime=${questionStartTime}`;

            console.log('üì± QR Code URL:', urlString);

            // Clear and regenerate QR code
            if (qrCodeContainer) {
                qrCodeContainer.innerHTML = '';
            }

            if (qrCodeInstance) {
                qrCodeInstance.clear();
                qrCodeInstance.makeCode(urlString);
            } else {
                qrCodeInstance = new QRCode(qrCodeContainer, { text: urlString, width: 192, height: 192, colorDark: "#0f172a", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H });
            }
        }

        function navigateToQuestion(index, options = {}) {
            const { force = false } = options;
            console.log('navigateToQuestion called with index:', index);
            const newIndex = 0; // Always use first question
            if (!force && newIndex === currentQuestionIndex && wordParticles.length > 0) {
                console.log('navigateToQuestion: Same question, particles exist, returning.');
                return;
            }

            currentQuestionIndex = newIndex;
            const question = QUESTIONS[currentQuestionIndex];

            updateQuestionMeta(question);

            resetDisplay();
            if (isMockMode) startRealtimeSimulation();
            else startRealtimeSubscription();
        }

        function extractWordInstances(answers) {
            console.log('extractWordInstances called with answers:', answers);
            const frequency = new Map();
            const baseCounts = new Map();
            const sanitized = [];

            const orderedAnswers = [...answers].reverse(); // oldest first

            orderedAnswers.forEach(answer => {
                console.log('Processing answer:', answer);
                if (!answer.answer_text) {
                    console.log('No answer_text found, skipping');
                    return;
                }
                const token = answer.answer_text.trim();
                console.log('answer_text:', token);
                if (token.length === 0) {
                    console.log('Empty token after trim, skipping');
                    return;
                }
                baseCounts.set(token, (baseCounts.get(token) || 0) + 1);
                sanitized.push({ token, answer });
            });

            sanitized.forEach(({ token, answer }) => {
                const uniqueKey = answer.id || `${token}-${answer.created_at || Date.now()}-${Math.random()}`;
                const weight = baseCounts.get(token) || 1;
                const createdAtTs = answer.created_at_ts || Date.parse(answer.created_at || '') || Date.now();
                frequency.set(uniqueKey, { text: token, weight, answerId: answer.id, createdAt: createdAtTs, answerRef: answer });
                console.log('Extracted unique token:', uniqueKey, 'weight:', weight);
            });

            console.log('Final frequency map:', frequency);
            return frequency;
        }

        function addAnswerToDisplay(answer) {
            displayAnswers.unshift(answer);
            if (displayAnswers.length > MAX_WORDS) {
                displayAnswers.pop();
            }
        }

        // --- Tetris-style Simulation Loop ---
        function simulationLoop(timestamp = performance.now()) {
            if (!wordParticles.some(p => p.state === 'falling')) {
                animationFrameId = null;
                lastFrameTime = null;
                return;
            }

            if (!lastFrameTime) lastFrameTime = timestamp;
            const delta = Math.min(0.05, (timestamp - lastFrameTime) / 1000);
            lastFrameTime = timestamp;

            wordParticles.forEach(p => updateFallingParticle(p, delta));

            animationFrameId = requestAnimationFrame(simulationLoop);
        }

        function renderWords(frequencyMap) {
            console.log('renderWords called with frequencyMap:', frequencyMap);

            updateGridMetrics(frequencyMap.size);

            if (frequencyMap.size === 0 && wordParticles.length === 0) {
                wordsLayer.innerHTML = '<div class="concept-empty">Ï≤´ Î≤àÏß∏ Îã®Ïñ¥Î•º Í∏∞Îã§Î¶¨Í≥† ÏûàÏñ¥Ïöî</div>';
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                tetrisGrid = createEmptyGrid();
                resetDropQueue();
                return;
            } else if (frequencyMap.size > 0 && wordsLayer.querySelector('.concept-empty')) {
                wordsLayer.innerHTML = '';
            }

            const existingParticles = new Map();
            wordParticles.forEach(p => existingParticles.set(p.key, p));

            const sortedWords = [...frequencyMap.entries()].sort((a, b) => {
                const aTime = a[1].createdAt || 0;
                const bTime = b[1].createdAt || 0;
                if (aTime === bTime) {
                    return a[0].localeCompare(b[0]);
                }
                return aTime - bTime;
            });
            const limited = sortedWords.slice(0, MAX_WORDS).filter(([, data]) => !hiddenWords.includes(data.text));
            const liveKeys = new Set(limited.map(item => item[0]));
            const maxWeight = limited.length ? Math.max(...limited.map(([, data]) => data.weight || 1)) : 1;

            prunePendingQueue(liveKeys);

            wordParticles = wordParticles.filter(p => {
                if (!liveKeys.has(p.key)) {
                    removeParticle(p, { immediate: true });
                    return false;
                }
                updateWordDimensions(p);
                return true;
            });
            const pendingEntries = [];

            limited.forEach(([key, data], index) => {
                const particle = existingParticles.get(key);
                const weightValue = data.weight || 1;
                if (particle) {
                    particle.weight = weightValue;
                    particle.answerRef = data.answerRef;
                    const weightRatio = maxWeight > 0 ? weightValue / maxWeight : 0;
                    const isHero = weightRatio > 0.7;
                    const isAccent = !isHero && weightRatio > 0.4;
                    particle.el.classList.toggle('concept-word-hero', isHero);
                    particle.el.classList.toggle('concept-word-accent', isAccent);
                    updateWordDimensions(particle);
                    if (particle.row !== null) {
                        const { x, y } = getCellCenter(particle.col, particle.row);
                        particle.x = x;
                        particle.y = y;
                        updateDomPosition(particle);
                    }
                    return;
                }

                if (!pendingParticleKeys.has(key)) {
                    pendingEntries.push({ key, data, index });
                }
            });

            pendingEntries.forEach(entry => {
                enqueueParticleCreation({
                    key: entry.key,
                    data: entry.data,
                    index: entry.index,
                    maxWeightSnapshot: maxWeight
                });
            });

            processPendingParticles();
            ensureAnimationLoop();
        }

        // --- Data Fetching & Control ---
        // No longer needed - using broadcast only

        function stopAllIntervals() {
            if (realtimeChannel) {
                supabase.removeChannel(realtimeChannel);
                realtimeChannel = null;
            }
            if (simulationInterval) clearInterval(simulationInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            simulationInterval = null;
            animationFrameId = null;
            lastFrameTime = null;
        }

        function resetDisplay() {
            console.log('resetDisplay called');
            stopAllIntervals();
            mockAnswers = [];
            displayAnswers = [];
            wordParticles = [];
            hiddenWords = [];
            resetDropQueue();
            wordsLayer.innerHTML = '';
            conceptTotal.textContent = '0';
            stopTimer();
            conceptUpdated.textContent = '10:00';
            mockWordQueue = shuffleArray([...MOCK_WORD_POOL]);
            mockWordIndex = 0;
            tetrisGrid = createEmptyGrid();
            lastFrameTime = null;
        }

        function startRealtimeSimulation() {
            console.log('startRealtimeSimulation called');
            resetDisplay();
            let count = 0;
            const question = QUESTIONS[currentQuestionIndex];
            startTimer();

            function generateSingleMockAnswer(questionId, index) {
                const currentQuestion = QUESTIONS.find(q => q.id === questionId);
                let answer;

                if (currentQuestion && currentQuestion.type === 'text') {
                    answer = getNextMockWord();
                } else {
                    answer = KEYWORDS[Math.floor(Math.random() * KEYWORDS.length)] || KEYWORDS[index % KEYWORDS.length];
                }

                // Apply 8 character limit (excluding spaces)
                const textWithoutSpaces = answer.replace(/\s+/g, '');
                if (textWithoutSpaces.length > 8) {
                    // Find the position in original string that gives us 8 non-space characters
                    let count = 0;
                    let cutIndex = 0;
                    for (let i = 0; i < answer.length; i++) {
                        if (answer[i] !== ' ') count++;
                        if (count === 8) {
                            cutIndex = i + 1;
                            break;
                        }
                    }
                    answer = answer.substring(0, cutIndex);
                }

                return {
                    id: `${questionId}-${index}-${Date.now()}`,
                    question_id: questionId,
                    answer: answer,
                    answer_text: answer,
                    created_at: new Date().toISOString(),
                    created_at_ts: Date.now()
                };
            }

            simulationInterval = setInterval(() => {
                if (count >= 300) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    return;
                }
                const newAnswer = generateSingleMockAnswer(question.id, count);
                mockAnswers.unshift(newAnswer);
                addAnswerToDisplay(newAnswer);
                const frequencyMap = extractWordInstances(displayAnswers);
                renderWords(frequencyMap);
                conceptTotal.textContent = mockAnswers.length;
                count++;
            }, 500);

            // Simulation loop is started by renderWords if words exist
        }

        async function startRealtimeSubscription() {
            console.log('startRealtimeSubscription called');
            stopAllIntervals();
            resetDropQueue();
            mockAnswers = [];
            wordParticles = [];
            hiddenWords = [];
            wordsLayer.innerHTML = '';
            conceptTotal.textContent = '0';
            stopTimer();
            conceptUpdated.textContent = '10:00';

            const question = QUESTIONS[currentQuestionIndex];
            if (!question) return;

            startTimer();

            // Track session start time - only show answers submitted after this point
            sessionStartTime = Date.now();
            console.log('üìç Session started at:', new Date(sessionStartTime).toISOString());

            // Poll for new answers every 2 seconds
            console.log('üîÑ Starting polling for new answers...');
            simulationInterval = setInterval(async () => {
                try {
                    const { data: newAnswers, error } = await supabase
                        .from('answers')
                        .select('*')
                        .eq('question_id', question.id)
                        .gte('created_at', new Date(sessionStartTime).toISOString())
                        .order('created_at', { ascending: false });

                    if (error) {
                        console.error('Polling error:', error);
                        return;
                    }

                    if (newAnswers && newAnswers.length > 0) {
                        console.log(`üîÑ Polled ${newAnswers.length} answers`);

                        // Check for new answers
                        const existingIds = new Set(mockAnswers.map(a => a.id));
                        const trulyNew = newAnswers.filter(a => !existingIds.has(a.id));

                        if (trulyNew.length > 0) {
                            console.log(`‚ú® Found ${trulyNew.length} new answers`);
                            trulyNew.forEach(a => {
                                const newAnswer = {
                                    id: a.id,
                                    question_id: a.question_id,
                                    answer: a.answer_text,
                                    answer_text: a.answer_text,
                                    created_at: a.created_at,
                                    created_at_ts: Date.parse(a.created_at) || Date.now()
                                };
                                mockAnswers.unshift(newAnswer);
                                addAnswerToDisplay(newAnswer);
                            });

                            const frequencyMap = extractWordInstances(displayAnswers);
                            renderWords(frequencyMap);
                            conceptTotal.textContent = mockAnswers.length;
                        }
                    }
                } catch (err) {
                    console.error('Polling exception:', err);
                }
            }, 2000); // Poll every 2 seconds
        }

        // --- Event Listeners ---
        toggleMockBtn.addEventListener('click', () => {
            console.log('toggleMockBtn clicked. isMockMode before:', isMockMode);
            isMockMode = !isMockMode;
            toggleMockBtn.classList.toggle('active', isMockMode);
            console.log('toggleMockBtn clicked. isMockMode after:', isMockMode);
            navigateToQuestion(currentQuestionIndex, { force: true });
        });

        window.addEventListener('resize', () => {
            updateGridMetrics(wordParticles.length);
            wordParticles.forEach(p => {
                updateWordDimensions(p);
                const baseRow = p.row !== null ? p.row : 0;
                const { x, y } = getCellCenter(p.col, baseRow);
                p.x = x;
                if (p.row !== null) {
                    p.y = y;
                }
                updateDomPosition(p);
            });
        });

        // --- Initial Load ---
        navigateToQuestion(0, { force: true });

        // Ï¥àÍ∏∞ Î≤ÑÌäº ÏÉÅÌÉú ÏÑ§Ï†ï
        if (isMockMode) {
            toggleMockBtn.classList.add('active');
        }
    </script>
</body>
</html>
