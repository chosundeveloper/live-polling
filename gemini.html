<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Polling - Gemini</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/motion@11.11.13/dist/motion.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @font-face {
            font-family: 'GangwonEduAll';
            src: url('fonts/GangwonEdu_OTFBoldA.woff') format('woff');
            font-weight: 600;
            font-style: normal;
        }

        body.concept-display,
        .concept-word {
            font-family: 'GangwonEduAll', 'Apple SD Gothic Neo', 'Noto Sans KR', sans-serif !important;
            font-weight: 700;
        }

        .concept-word {
            padding: 8px 16px !important;
            border-radius: 8px;
            transition: color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
            /* Smooth color transitions */
        }

        /* Removed vertical word styling: all words stay horizontal */
    </style>
</head>

<body class="concept-body concept-display">
    <div class="concept-wrapper">
        <header class="concept-top">
            <div class="concept-title-nav">
                <div class="concept-question-display">
                    <h2 id="conceptQuestion">ÏßàÎ¨∏ Î°úÎî© Ï§ë...</h2>
                </div>
            </div>
        </header>

        <main class="concept-cloud">
            <div class="concept-decorations">
                <div class="concept-decoration bubble" style="top: 70%; left: 25%; animation-delay: 1s;"></div>
                <div class="concept-decoration bubble" style="top: 60%; left: 90%; animation-delay: 2.5s;"></div>
                <div class="concept-decoration bubble" style="top: 80%; left: 40%; animation-delay: 1.8s;"></div>
                <div class="concept-decoration bubble" style="top: 75%; left: 5%; animation-delay: 0.5s;"></div>
                <div class="concept-decoration bubble" style="top: 85%; left: 60%; animation-delay: 3.2s;"></div>
                <div class="concept-decoration bubble" style="top: 65%; left: 75%; animation-delay: 2.0s;"></div>
                <div class="concept-decoration bubble" style="top: 90%; left: 15%; animation-delay: 0.8s;"></div>
                <div class="concept-decoration bubble" style="top: 55%; left: 50%; animation-delay: 4.0s;"></div>
                <div class="concept-decoration bubble" style="top: 95%; left: 85%; animation-delay: 1.5s;"></div>
                <div class="concept-decoration bubble" style="top: 70%; left: 95%; animation-delay: 3.5s;"></div>
                <div class="concept-decoration bubble" style="top: 80%; left: 30%; animation-delay: 2.8s;"></div>
                <div class="concept-decoration bubble" style="top: 88%; left: 70%; animation-delay: 0.3s;"></div>
                <div class="concept-decoration bubble" style="top: 75%; left: 10%; animation-delay: 4.5s;"></div>
                <div class="concept-decoration bubble" style="top: 92%; left: 55%; animation-delay: 1.2s;"></div>
                <div class="concept-decoration bubble" style="top: 68%; left: 45%; animation-delay: 3.8s;"></div>

                <!-- Red Hearts -->
                <div class="concept-decoration heart" style="top: 15%; left: 10%; animation-delay: 0.5s;">‚ô•</div>
                <div class="concept-decoration heart" style="top: 25%; left: 85%; animation-delay: 1.8s;">‚ô•</div>
                <div class="concept-decoration heart" style="top: 40%; left: 20%; animation-delay: 3.2s;">‚ô•</div>
                <div class="concept-decoration heart" style="top: 50%; left: 92%; animation-delay: 2.1s;">‚ô•</div>
                <div class="concept-decoration heart" style="top: 35%; left: 65%; animation-delay: 4.0s;">‚ô•</div>
                <div class="concept-decoration heart" style="top: 28%; left: 50%; animation-delay: 2.7s;">‚ô•</div>
                <div class="concept-decoration heart" style="top: 45%; left: 8%; animation-delay: 3.9s;">‚ô•</div>
                <div class="concept-decoration heart" style="top: 18%; left: 72%; animation-delay: 1.3s;">‚ô•</div>

                <!-- White Stars -->
                <div class="concept-decoration star" style="top: 20%; left: 45%; animation-delay: 1.2s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 30%; left: 5%; animation-delay: 2.5s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 45%; left: 78%; animation-delay: 0.8s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 55%; left: 35%; animation-delay: 3.5s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 38%; left: 95%; animation-delay: 1.5s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 22%; left: 28%; animation-delay: 3.8s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 48%; left: 58%; animation-delay: 2.2s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 32%; left: 88%; animation-delay: 4.1s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 42%; left: 12%; animation-delay: 1.9s;">‚òÖ</div>
                <div class="concept-decoration star" style="top: 52%; left: 68%; animation-delay: 3.3s;">‚òÖ</div>
            </div>
            <div class="concept-words" id="conceptWords"></div>
            <div class="concept-overlay concept-overlay-bottom-left">
                <div class="concept-qr-card">
                    <div class="concept-qr-box" id="conceptQrCode"></div>
                    <div class="concept-qr-meta">
                        <a class="concept-link" id="conceptLink" href="#" target="_blank" rel="noopener">ÎßÅÌÅ¨ Ï§ÄÎπÑ Ï§ë</a>
                    </div>
                </div>
            </div>
            <div class="concept-overlay concept-overlay-bottom-right">
                <div class="concept-stats-card">
                    <div class="concept-total-block">
                        <p class="concept-label">ÎàÑÏ†Å ÎãµÎ≥Ä</p>
                        <p class="concept-value" id="conceptTotal">0</p>
                    </div>
                    <div class="concept-timer-row">
                        <div class="concept-clock-wrapper">
                            <p class="concept-value concept-clock-value" id="conceptClock">--:--:--</p>
                        </div>
                        <div class="concept-timer-block">
                            <p class="concept-label">ÌÉÄÏù¥Î®∏</p>
                            <p class="concept-value" id="conceptUpdated">02:00</p>
                        </div>
                        <button class="concept-action concept-action-ghost" id="toggleMock">Î™®Ïùò</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>


        // Questions loaded from supabase-config.js

        // Public URL for QR code (GitHub Pages)
        const PUBLIC_URL = 'https://chosundeveloper.github.io/live-polling';

        // Timer state
        let questionStartTime = null;

        // --- DOM Elements ---
        const conceptQuestion = document.getElementById('conceptQuestion');
        const wordsLayer = document.getElementById('conceptWords');
        const conceptTotal = document.getElementById('conceptTotal');
        const conceptUpdated = document.getElementById('conceptUpdated');
        const conceptClock = document.getElementById('conceptClock');
        const qrCodeContainer = document.getElementById('conceptQrCode');
        const conceptLink = document.getElementById('conceptLink');
        const qrCard = document.querySelector('.concept-qr-card');
        const toggleMockBtn = document.getElementById('toggleMock');

        function updateMockButtonState() {
            if (!toggleMockBtn) return;
            let label = 'Î™®Ïùò';
            if (isMockMode) {
                label = isMockPaused ? 'Î™®Ïùò Ïû¨Í∞ú' : 'Î™®Ïùò ÏùºÏãúÏ†ïÏßÄ';
            }
            toggleMockBtn.textContent = label;
            toggleMockBtn.classList.toggle('active', isMockMode);
            toggleMockBtn.classList.toggle('paused', isMockPaused);
        }

        function ensureQrVisible() {
            if (!qrCard) return;
            qrCard.style.display = 'flex';
            qrCard.style.visibility = 'visible';
            qrCard.style.opacity = '1';
        }

        function updateCurrentTime() {
            if (!conceptClock) return;
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            conceptClock.textContent = `${hours}:${minutes}:${seconds}`;
        }

        function startClock() {
            if (!conceptClock) return;
            if (clockInterval) {
                clearInterval(clockInterval);
            }
            updateCurrentTime();
            clockInterval = setInterval(updateCurrentTime, 1000);
        }

        // --- State ---
        const params = new URLSearchParams(window.location.search);
        let currentQuestionIndex = 0;
        let isMockMode = params.get('mock') === '1';
        let realtimeChannel = null;
        let simulationInterval = null;
        let mockAnswers = [];
        let wordParticles = [];
        let hiddenWords = [];
        let qrCodeInstance = null;
        let animationFrameId = null;
        let timerInterval = null;
        let timerDeadline = null;
        let d3Simulation = null;
        let isTimerExpired = false;
        let sessionStartTime = null; // Ïã§Ï†ú Î™®ÎìúÏóêÏÑú ÏÉà ÏùëÎãµÎßå ÌëúÏãú
        let isMockPaused = false;
        let pausedTimerRemaining = null;
        let mockGeneratedCount = 0;
        let totalAnswerCount = 0;
        let clockInterval = null;
        const seenAnswerIds = new Set();

        // --- Constants ---
        const KEYWORDS = ['Í∞êÏÇ¨Ìïú ÎßàÏùå', 'Í∏∞ÏÅ®Ïù¥ ÎÑòÏπ®', 'ÌèâÏïàÍ≥º ÏùÄÌòú', 'ÌöåÍ∞úÏôÄ ÌöåÎ≥µ', 'Ï∞¨ÏñëÍ≥º Í≤ΩÎ∞∞', 'ÏÇ¨ÎûëÏùò Ï∂©ÎßåÌï®', 'ÏÜåÎßùÍ≥º ÎØøÏùå', 'Í≤∏ÏÜêÌïú ÏàúÏ¢Ö', 'Í∞êÍ≤©Ïä§Îü¨Ïö¥ Í∞êÏÇ¨', 'Í∞ÑÏ†àÌïú Í∏∞ÎèÑ', 'Îú®Í±∞Ïö¥ ÌóåÏã†', 'ÏûîÏûîÌïú ÌèâÏò®', 'ÏÉàÎ°úÏö¥ ÏùÄÌòú', 'ÍπäÏùÄ Í∞àÎßù', 'ÏßÑÏã§Ìïú Í≥†Î∞±', 'Ï∂ïÎ≥µÏùò ÏãúÍ∞Ñ', 'ÏπòÏú†ÏôÄ ÌöåÎ≥µ', 'ÏÉà ÌûòÏùÑ ÏñªÏùå', 'Í∞êÎèôÏùò ÏàúÍ∞Ñ', 'Ï∂©ÎßåÌïú Í∏∞ÏÅ®', 'Îî∞ÎúªÌïú ÏÇ¨Îûë', 'Í∞ÑÍµ¨ÌïòÎäî ÎßàÏùå', 'Í≤ΩÎ∞∞ÏôÄ Ï∞¨Ïñë', 'ÎØøÏùåÏùò Í≥†Î∞±', 'ÏÜåÎßùÏùÑ ÌíàÏùå'];
        const PREFIXES = ['Îî∞ÎúªÌïòÍ≥† ÍπäÏùÄ', 'ÏÉàÎ°≠Í≥† Îú®Í±∞Ïö¥', 'Í∞ÑÏ†àÌïòÍ≥† Í≤∏ÏÜêÌïú', 'ÏßÑÏã§ÌïòÍ≥† ÏûîÏûîÌïú', 'Ï∂©ÎßåÌïòÍ≥† Í∏∞ÏÅú'];
        const SUFFIXES = ['ÎßàÏùåÍ≥º ÏòÅÌòº', 'Í∞êÏÇ¨ÏôÄ ÏùÄÌòú', 'Í∏∞ÏÅ®Í≥º ÌèâÏïà', 'ÏÜåÎßùÍ≥º ÎØøÏùå', 'ÏÇ¨ÎûëÍ≥º Ï∞¨Ïñë'];
        const TEXT_ANSWERS = [
            'Í∞êÏÇ¨Ìïú ÎßàÏùåÏúºÎ°ú',
            'Í∏∞ÏÅ®Ïù¥ ÎÑòÏπòÎäî',
            'ÌèâÏïàÍ≥º ÏùÄÌòúÍ∞Ä',
            'ÌöåÍ∞úÏôÄ ÌöåÎ≥µÏùò',
            'Ï∞¨ÏñëÍ≥º Í≤ΩÎ∞∞Î•º',
            'ÏÇ¨ÎûëÏùò Ï∂©ÎßåÌï®',
            'ÏÜåÎßùÍ≥º ÎØøÏùåÏúºÎ°ú',
            'Í≤∏ÏÜêÌïú ÏàúÏ¢ÖÏùò',
            'Í∞êÍ≤©Ïä§Îü¨Ïö¥ Í∞êÏÇ¨',
            'Í∞ÑÏ†àÌïú Í∏∞ÎèÑÏ†úÎ™©',
            'Îú®Í±∞Ïö¥ ÌóåÏã†ÏúºÎ°ú',
            'ÏûîÏûîÌïú ÌèâÏò®Ìï®',
            'ÏÉàÎ°úÏö¥ ÏùÄÌòúÎ•º',
            'ÍπäÏùÄ Í∞àÎßùÏúºÎ°ú',
            'ÏßÑÏã§Ìïú Í≥†Î∞±ÏùÑ',
            'Ï∂ïÎ≥µÏùò ÏãúÍ∞ÑÎì§',
            'ÏπòÏú†ÏôÄ ÌöåÎ≥µÏùÑ',
            'ÏÉà ÌûòÏùÑ ÏñªÏùå',
            'Í∞êÎèôÏùò ÏàúÍ∞ÑÎì§',
            'Ï∂©ÎßåÌïú Í∏∞ÏÅ®Í≥º',
            'Îî∞ÎúªÌïú ÏÇ¨ÎûëÏúºÎ°ú',
            'Í∞ÑÍµ¨ÌïòÎäî ÎßàÏùå',
            'Í≤ΩÎ∞∞ÏôÄ Ï∞¨ÏñëÏùÑ',
            'ÎØøÏùåÏùò Í≥†Î∞±ÏúºÎ°ú',
            'ÏÜåÎßùÏùÑ ÌíàÍ≥†ÏÑú',
            'ÏùÄÌòúÎ°úÏö¥ Ï£ºÎãò',
            'Í∞êÏÇ¨ÏôÄ Í∏∞ÏÅ®Ïùò',
            'ÏÇ¨ÎûëÍ≥º ÌèâÏïàÏù¥',
            'ÎØøÏùåÏúºÎ°ú ÎÇòÏïÑÍ∞ê',
            'ÏÜåÎßù Í∞ÄÏö¥Îç∞ÏÑú',
            'Ï£ºÏùò ÏùÄÌòú ÏïàÏóê',
            'Ï∞¨ÏñëÌïòÎäî ÏÇ∂ÏúºÎ°ú',
            'Í∏∞ÎèÑÌïòÎäî ÎßàÏùå',
            'ÌóåÏã†Ïùò Îã§ÏßêÏùÑ',
            'ÌöåÍ∞úÌïòÎäî Ïã¨Î†π',
            'Í∞êÏÇ¨Ìï®Ïù¥ ÎÑòÏ≥êÏöî',
            'Ï£ºÎãò ÏÇ¨ÎûëÌï¥Ïöî',
            'ÏùÄÌòúÍ∞Ä Í∞ÄÎìùÌï¥Ïöî',
            'Í∏∞ÏÅ®ÏúºÎ°ú Ï∞¨ÏñëÌï¥Ïöî',
            'ÌèâÏïàÌï®ÏùÑ ÎäêÍª¥Ïöî',
            'ÏÇ¨ÎûëÏù¥ Ï∂©ÎßåÌï¥Ïöî',
            'ÏÜåÎßùÏùÑ ÌíàÏñ¥Ïöî',
            'ÎØøÏùåÏúºÎ°ú ÏÇ¥ÏïÑÏöî',
            'Í∞ÑÏ†àÌûà Í∏∞ÎèÑÌï¥Ïöî',
            'Í∞êÍ≤©Ïä§Îü¨ÏõåÏöî',
            'ÌöåÍ∞úÌïòÍ≥† Ïã∂Ïñ¥Ïöî',
            'ÏπòÏú†Î•º Î∞îÎùºÏöî',
            'Ï∂ïÎ≥µÏùÑ Íµ¨Ìï¥Ïöî',
            'ÌóåÏã†ÌïòÍ≥† Ïã∂Ïñ¥Ïöî',
            'Í∞êÎèôÏù¥ Î∞ÄÎ†§ÏôÄÏöî',
            'Í∞êÏÇ¨Ìï®ÏúºÎ°ú Í∞ÄÎìùÌï¥Ïöî',
            'Ï£ºÎãòÍªò ÏòÅÍ¥ë ÎèåÎ†§Ïöî',
            'ÏùÄÌòúÎ•º Î∞õÏïòÏñ¥Ïöî',
            'Í∏∞ÏÅ®ÏúºÎ°ú Ï∞¨ÏñëÎìúÎ†§Ïöî',
            'ÌèâÏïàÌï®Ïù¥ ÎÑòÏ≥êÎÇòÏöî',
            'ÏÇ¨ÎûëÏù¥ Í∞ÄÎìùÌï©ÎãàÎã§',
            'ÏÜåÎßùÏùÑ Í∞ÄÏßÄÍ≥† ÏûàÏñ¥Ïöî',
            'ÎØøÏùåÏúºÎ°ú Í±∏Ïñ¥Í∞ÄÏöî',
            'Í∞ÑÏ†àÌûà Í∏∞ÎèÑÎìúÎ†§Ïöî',
            'Í∞êÍ≤©Ïä§Îü¨Ïö¥ ÏàúÍ∞ÑÏù¥ÏóêÏöî',
            'ÌöåÍ∞úÌïòÍ≥† ÎèåÏù¥ÏºúÏöî',
            'ÏπòÏú†Î•º Í∞ÑÏ†àÌûà Î∞îÎùºÏöî',
            'Ï∂ïÎ≥µÏùÑ Î∞õÍ∏∞ ÏõêÌï¥Ïöî',
            'ÌóåÏã†ÌïòÍ≥† Ïã∂ÏäµÎãàÎã§',
            'Í∞êÎèôÏù¥ Î∞ÄÎ†§ÏòµÎãàÎã§',
            'Ï£ºÎãòÏùÑ Ï∞¨ÏñëÌï©ÎãàÎã§',
            'ÏùÄÌòúÎ°ú Ï∂©ÎßåÌï©ÎãàÎã§',
            'Í∏∞ÏÅ®Ïù¥ ÎÑòÏπ©ÎãàÎã§',
            'ÌèâÏïàÏùÑ ÎàÑÎ¶ΩÎãàÎã§',
            'ÏÇ¨ÎûëÏùÑ Ï†ÑÌï©ÎãàÎã§',
            'ÏÜåÎßùÏùÑ ÌíàÏäµÎãàÎã§',
            'ÎØøÏùåÏùÑ Í≥†Î∞±Ìï©ÎãàÎã§',
            'Í∞êÏÇ¨Î•º ÎìúÎ¶ΩÎãàÎã§',
            'ÌöåÍ∞úÎ•º Ìï©ÎãàÎã§',
            'ÏπòÏú†Î•º Íµ¨Ìï©ÎãàÎã§',
            'Ï∂ïÎ≥µÏùÑ ÎπïÎãàÎã§',
            'ÌóåÏã†ÏùÑ Îã§ÏßêÌï©ÎãàÎã§',
            'Í≤ΩÎ∞∞Î•º ÎìúÎ¶ΩÎãàÎã§',
            'Ï∞¨ÏñëÏùÑ Ïò¨Î¶ΩÎãàÎã§',
            'Í∏∞ÎèÑÎ•º Ïò¨Î¶ΩÎãàÎã§',
            'Ï£ºÎãòÍªòÏÑú Ìï®ÍªòÌïòÏÑ∏Ïöî',
            'ÏùÄÌòúÍ∞Ä ÎÑòÏ≥êÌùêÎ•¥ÎÑ§Ïöî',
            'ÏÇ¨ÎûëÏúºÎ°ú Ï∂©ÎßåÌïòÎÑ§Ïöî',
            'ÌèâÏïàÌï®Ïù¥ Í∞ÄÎìùÌï¥Ïöî',
            'Í∞êÏÇ¨Ìï®ÏúºÎ°ú ÏÇ¥ÏïÑÍ∞ÄÏöî',
            'ÏÜåÎßùÏùÑ Í∞ÑÏßÅÌïòÍ≥† ÏûàÏñ¥Ïöî',
            'ÎØøÏùåÏúºÎ°ú ÏäπÎ¶¨ÌïòÏÑ∏Ïöî',
            'Ï∞¨ÏñëÌï®Ïù¥ Í∑∏ÏπòÏßÄ ÏïäÏïÑÏöî',
            'Í∏∞ÎèÑÌïòÎ©∞ ÎÇòÏïÑÍ∞ÄÍ≥† ÏûàÏñ¥Ïöî',
            'ÌöåÍ∞úÌïòÍ≥† ÎèåÏù¥ÏºúÏöî',
            'ÏπòÏú†ÌïòÏã¨ÏùÑ Í≤ΩÌóòÌï¥Ïöî',
            'Ï∂ïÎ≥µÌïòÏã¨ÏùÑ ÎàÑÎ†§Ïöî',
            'ÌóåÏã†ÌïòÎ©∞ ÏÇ¥ÏïÑÍ∞ÄÍ≥† ÏûàÏñ¥Ïöî',
            'Í≤ΩÎ∞∞ÌïòÎ©∞ Ï∞¨ÏñëÎìúÎ†§Ïöî',
            'Í∞êÍ≤©Ïä§Îü¨Ïõå ÎààÎ¨ºÎÇòÏöî'
        ];
        const FIXED_FONT_SIZE = 22; // Fixed font size for all words
        const MAX_PARTICLE_SPEED = 0.4; // Slower speed for smoother feel
        const MIN_SEPARATION = 500;
        const DEFAULT_PARTICLE_WIDTH = 200; // Reverted to match display.html
        const DEFAULT_PARTICLE_HEIGHT = 60; // Reverted to match display.html

        const WORD_PADDING = 100; // Reverted to match display.html
        const EDGE_PADDING_RATIO_X = 0.004;
        const EDGE_PADDING_RATIO_Y = 0.025;
        const MIN_EDGE_PADDING_X = 6;
        const MIN_EDGE_PADDING_Y = 24;
        const RIGHT_EDGE_EXTRA_PADDING_RATIO = 0.01;
        const MIN_RIGHT_EDGE_EXTRA_PADDING = 10;
        const LAYOUT_CLAMP_BUFFER_X = 10;
        const LAYOUT_CLAMP_BUFFER_Y = 14;
        const MAX_DISPLAYED_WORDS = 100;
        const MIN_TARGET_WORDS = 80;
        const MAX_VISIBLE_WORDS = 60;

        // Calculate max words based on screen space
        function calculateMaxWords() {
            const layout = getLayoutMetrics();
            const avgWordWidth = 180;
            const avgWordHeight = 60;
            const padding = 30;

            const wordsPerRow = Math.max(1, Math.floor(layout.usableWidth / (avgWordWidth + padding)));
            const wordsPerColumn = Math.max(1, Math.floor(layout.usableHeight / (avgWordHeight + padding)));
            const maxCapacity = Math.max(wordsPerRow * wordsPerColumn, 1);

            // Target exactly 100 words if space permits
            // Use 80% capacity to allow reaching 100 words while relying on physics to prevent overlap
            const desiredDensity = Math.floor(maxCapacity * 0.95);
            const densityLimit = Math.min(maxCapacity, Math.max(MIN_TARGET_WORDS, desiredDensity));
            const MAX_WORDS = Math.min(MAX_DISPLAYED_WORDS, densityLimit);

            console.log(`üìê Screen capacity: ${maxCapacity}, Density Limit: ${densityLimit}, Using: ${MAX_WORDS} max words (Target 100)`);
            return MAX_WORDS;
        }

        let MAX_WORDS = MAX_DISPLAYED_WORDS; // Maximum visible words capped by density
        const INTRO_DURATION_BASE = 180000; // extremely slow duration (3 minutes)
        const INTRO_DURATION_VARIANCE = 20000;
        const INTRO_BLOOM_JITTER = 0; // No bloom
        const INTRO_SPIRAL_TWIST = 0; // No spiral
        const INTRO_SWAY_AMPLITUDE = 0; // No sway
        const INTRO_SWAY_FREQUENCY = 1.1;
        const INTRO_STAGE_MIN_RADIUS = 10;
        const INTRO_STAGE_MAX_RADIUS = 40;
        const INTRO_CLUSTER_RATIO = 0.3; // 30% for gathering, 70% for spreading (slower spread)
        const INTRO_CLUSTER_SWAY = 0;
        const INTRO_CLUSTER_PADDING = 400;
        const OUTWARD_DRIFT_FORCE = 0.000002;
        const TARGET_ATTRACTION_FORCE = 0.000001;
        const RADIAL_FORCE = 0.000004;
        const MIN_WORD_LIFETIME = 7000;
        const MOCK_BATCH_INTERVAL = 400; // Add new words more slowly
        const MOCK_BATCH_SIZE = 2; // Small batch to prevent sudden crowding
        const MAX_INPUT_CHARS = 12;
        const LINE_BREAK_THRESHOLD = 6;
        const TIMER_DURATION_MS = 120 * 1000; // 120 seconds (2 minutes)
        const COLOR_PALETTE = ['#5e4fa2', '#3288bd', '#66c2a5', '#abdda4', '#e6f598', '#fee08b', '#fdae61', '#f46d43', '#d53e4f', '#9e0142'];
        // Exclude yellow (#e6f598 index 4), lime green (#abdda4 index 3), light orange (#fee08b index 5), orange (#fdae61 index 6), and dark red (#9e0142 index 9)
        const EXCLUDED_COLOR_INDICES = [3, 4, 5, 6, 9];
        const MAX_CELL_SPREAD_RATIO = 0.6; // Use even more of the canvas
        const INNER_CORE_RATIO = 0.06; // Inner core that stays stable (very small)
        const PUSH_THRESHOLD_RATIO = 0.10; // Start pushing outward very early
        function clampValue(value, min, max) {
            if (Number.isNaN(value)) return min;
            return Math.min(Math.max(value, min), max);
        }

        function getBoundaryPadding(width, height) {
            const baseX = Math.max(width * EDGE_PADDING_RATIO_X, MIN_EDGE_PADDING_X);
            const baseY = Math.max(height * EDGE_PADDING_RATIO_Y, MIN_EDGE_PADDING_Y);
            const extraRight = Math.max(width * RIGHT_EDGE_EXTRA_PADDING_RATIO, MIN_RIGHT_EDGE_EXTRA_PADDING);
            return {
                left: baseX,
                right: baseX + extraRight,
                top: baseY,
                bottom: baseY
            };
        }

        function getLayoutMetrics() {
            const bounds = getCloudBounds();
            const padding = getBoundaryPadding(bounds.width, bounds.height);
            const usableWidth = Math.max(120, bounds.width - padding.left - padding.right);
            const usableHeight = Math.max(120, bounds.height - padding.top - padding.bottom);
            const centerW = padding.left + usableWidth / 2;
            const centerH = padding.top + usableHeight / 2;
            return {
                width: bounds.width,
                height: bounds.height,
                padding,
                usableWidth,
                usableHeight,
                centerW,
                centerH
            };
        }

        function selectWordColor(weightRatio, index) {
            // Always return navy color
            return 'rgba(30, 41, 59, 0.9)';
        }
        window.selectWordColor = selectWordColor;

        function getWordLines(rawText = '') {
            const normalized = rawText.replace(/\s+/g, ' ').trim();
            const cleanLength = normalized.replace(/\s+/g, '').length;

            // If more than 6 characters (7+) and has space, break into two lines
            if (cleanLength > LINE_BREAK_THRESHOLD && normalized.includes(' ')) {
                // Find first space to split
                const spaceIndex = normalized.indexOf(' ');
                if (spaceIndex > 0) {
                    const firstLine = normalized.slice(0, spaceIndex).trim();
                    const secondLine = normalized.slice(spaceIndex + 1).trim();
                    if (firstLine && secondLine) {
                        return { lines: [firstLine, secondLine], multiline: true, normalized };
                    }
                }
            }

            // Default: single line
            return { lines: normalized ? [normalized] : [], multiline: false, normalized };
        }

        function applyWordLayout(wordEl, rawText = '') {
            if (!wordEl) return null;
            const { lines, multiline, normalized } = getWordLines(rawText);
            const effectiveLines = lines.length > 0 ? lines : [''];
            wordEl.textContent = '';
            const fragment = document.createDocumentFragment();
            effectiveLines.forEach((line, idx) => {
                const textSpan = document.createElement('span');
                textSpan.className = 'concept-char concept-word-block';
                textSpan.textContent = line;
                fragment.appendChild(textSpan);
                if (multiline && idx === 0) {
                    fragment.appendChild(document.createElement('br'));
                }
            });
            wordEl.appendChild(fragment);
            wordEl.classList.toggle('concept-word-multiline', multiline);
            wordEl.dataset.originalText = normalized;
            wordEl.dataset.charsSplit = '1';
            return wordEl.querySelectorAll('.concept-char');
        }

        function splitWordIntoCharacters(wordEl) {
            if (!wordEl) {
                return null;
            }
            if (wordEl.dataset.charsSplit === '1') {
                return wordEl.querySelectorAll('.concept-char');
            }
            const source = wordEl.dataset.originalText || wordEl.textContent || '';
            return applyWordLayout(wordEl, source);
        }

        function animateWordEntry(wordEl) {
            if (!wordEl) {
                return;
            }

            const initialSize = FIXED_FONT_SIZE * 1.2;
            const finalSize = FIXED_FONT_SIZE;

            // Force horizontal writing mode - prevent vertical text
            wordEl.style.writingMode = 'horizontal-tb';
            wordEl.style.textOrientation = 'mixed';

            // Also apply to all child elements
            const children = wordEl.querySelectorAll('*');
            children.forEach(child => {
                child.style.writingMode = 'horizontal-tb';
                child.style.textOrientation = 'mixed';
            });

            // Set initial large size and opacity with CSS
            wordEl.style.fontSize = `${initialSize}px`;
            wordEl.style.opacity = '0';
            wordEl.style.transition = 'none';
            wordEl.style.transform = 'translate(-50%, -50%) scale(0.5)'; // Start small

            // Force reflow
            wordEl.offsetHeight;

            // Start animation after a small delay
            requestAnimationFrame(() => {
                wordEl.style.transition = 'font-size 1.5s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 1.5s ease-out, transform 1.5s cubic-bezier(0.2, 0.8, 0.2, 1)';
                wordEl.style.fontSize = `${finalSize}px`;
                wordEl.style.opacity = '1';
                wordEl.style.transform = 'translate(-50%, -50%) scale(1)';
            });
        }

        function getCloudBounds() {
            const rect = wordsLayer.getBoundingClientRect();
            let width = rect.width;
            let height = rect.height;
            if (width > 10 && height > 10) {
                return { width, height };
            }
            const parentRect = wordsLayer.parentElement?.getBoundingClientRect();
            width = parentRect?.width || window.innerWidth;
            height = parentRect?.height || window.innerHeight;
            return { width, height };
        }

        const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));

        function getSpiralGeometry(layout, wordCount = MAX_WORDS) {
            const baseDiameter = Math.min(layout.usableWidth, layout.usableHeight);
            const baseRadius = (baseDiameter / 2) * (MAX_CELL_SPREAD_RATIO + 0.08);
            const limitedRadius = Math.max(60, Math.min(baseRadius, baseDiameter / 2));
            const usableRadius = Math.max(60, limitedRadius);
            const maxRadius = usableRadius * 0.95; // Slightly smaller to stay within bounds
            const minRadius = Math.max(25, maxRadius * 0.12);
            const count = Math.max(1, wordCount);
            const ringCount = Math.min(10, Math.max(3, Math.ceil(count / 25)));
            const ringSpan = (maxRadius - minRadius) / Math.max(1, ringCount - 1);
            const rings = [];
            let startIndex = 0;
            // Fill from outside to inside: start with maxRadius
            for (let i = 0; i < ringCount; i++) {
                const radius = maxRadius - ringSpan * i;
                const circumference = 2 * Math.PI * Math.max(40, radius);
                const capacity = Math.max(8, Math.round(circumference / 70));
                rings.push({ radius, start: startIndex, end: startIndex + capacity });
                startIndex += capacity;
            }
            // Ensure total coverage
            if (startIndex < count) {
                const extra = count - startIndex;
                rings[rings.length - 1].end += extra;
            }
            return { rings, count };
        }

        function assignParticleTarget(particle, layout, geometry, spiralIndex = 0) {
            const clampedIndex = Math.max(0, Math.min(spiralIndex, geometry.count - 1));
            const ring = geometry.rings.find(r => clampedIndex < r.end) || geometry.rings[geometry.rings.length - 1];
            const radius = ring.radius;
            const angle = clampedIndex * GOLDEN_ANGLE;
            const jitterAngle = angle + (Math.random() - 0.5) * 0.04;
            const jitterRadius = radius + (Math.random() - 0.5) * Math.max(6, radius * 0.02);
            const rawX = layout.centerW + Math.cos(jitterAngle) * jitterRadius;
            const rawY = layout.centerH + Math.sin(jitterAngle) * jitterRadius;
            const minX = layout.padding.left + LAYOUT_CLAMP_BUFFER_X;
            const maxX = layout.width - layout.padding.right - LAYOUT_CLAMP_BUFFER_X;
            const minY = layout.padding.top + LAYOUT_CLAMP_BUFFER_Y;
            const maxY = layout.height - layout.padding.bottom - LAYOUT_CLAMP_BUFFER_Y;
            particle.targetX = clampValue(rawX, minX, maxX);
            particle.targetY = clampValue(rawY, minY, maxY);
            particle.spiralIndex = clampedIndex;
            particle.ringRadius = radius;
            particle.ringAngle = jitterAngle;
        }

        function getParticleDimensions(particle) {
            const width = particle.width || particle.el.offsetWidth || DEFAULT_PARTICLE_WIDTH;
            const height = particle.height || particle.el.offsetHeight || DEFAULT_PARTICLE_HEIGHT;
            particle.width = width;
            particle.height = height;
            return { width, height };
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimerDisplay() {
            if (!timerDeadline) {
                conceptUpdated.textContent = '02:00';
                return;
            }
            const remaining = Math.max(0, timerDeadline - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = String(Math.floor((remaining % 60000) / 1000)).padStart(2, '0');
            conceptUpdated.textContent = `${minutes}:${seconds}`;
            if (remaining <= 0) {
                stopTimer();
                if (!isTimerExpired) {
                    handleTimerExpiration();
                }
            }
        }

        function startTimer() {
            stopTimer();
            isTimerExpired = false;
            timerDeadline = Date.now() + TIMER_DURATION_MS;
            pausedTimerRemaining = null;
            updateTimerDisplay();
            timerInterval = setInterval(updateTimerDisplay, 1000);
        }

        function handleTimerExpiration() {
            isTimerExpired = true;
            console.log('‚è∞ Timer completed');
            if (isMockMode) {
                stopMockSimulation();
            }
        }

        function updateParticleTargets() {
            if (!wordParticles.length) return;
            const layout = getLayoutMetrics();
            const geometry = getSpiralGeometry(layout, wordParticles.length);
            wordParticles.forEach(p => assignParticleTarget(p, layout, geometry, p.spiralIndex || 0));

            // Reinitialize D3 simulation with updated targets
            if (d3Simulation) {
                initD3Simulation(layout);
            }
        }

        // --- Core Functions ---
        function updateQuestionMeta(question, options = {}) {
            const { preserveQr = false } = options;
            conceptQuestion.textContent = question.question;
            document.documentElement.style.setProperty('--concept-accent', question.color || '#7c3aed');

            if (!preserveQr) {
                // Set question start time for timer sync
                questionStartTime = Date.now();
                timerDeadline = questionStartTime + TIMER_DURATION_MS;

                // Pass START TIME (not deadline) so timer syncs correctly
                const urlString = `${PUBLIC_URL}/answer.html?q=${question.id}&startTime=${questionStartTime}`;

                // Clear and regenerate QR code
                if (qrCodeContainer) {
                    qrCodeContainer.innerHTML = '';
                }

                if (qrCodeInstance) {
                    qrCodeInstance.clear();
                    qrCodeInstance.makeCode(urlString);
                } else {
                    qrCodeInstance = new QRCode(qrCodeContainer, { text: urlString, width: 192, height: 192, colorDark: "#0f172a", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H });
                }

                if (conceptLink) {
                    conceptLink.textContent = urlString;
                    conceptLink.href = urlString;
                }
            }
            ensureQrVisible();
        }

        function navigateToQuestion(index, options = {}) {
            const { force = false, preserveQr = false } = options;
            const newIndex = 0; // Always use first question
            if (!force && newIndex === currentQuestionIndex && wordParticles.length > 0) {
                return;
            }

            currentQuestionIndex = newIndex;
            const question = QUESTIONS[currentQuestionIndex];

            updateQuestionMeta(question, { preserveQr });

            if (isMockMode) startRealtimeSimulation({ reset: true });
            else startRealtimeSubscription();
        }

        function extractWordInstances(answers) {
            const instances = new Map();
            console.log(`üìä Processing ${answers.length} total answers`);
            answers.forEach((answer, idx) => {
                if (!answer.answer_text) {
                    return;
                }
                // Each answer is a separate instance, even if text is duplicate
                const token = answer.answer_text.trim();
                if (token.length > 0) {
                    // Use unique key: answer_id + index to keep each instance separate
                    const uniqueId = answer.id ? `${answer.id}` : `temp_${idx}_${Date.now()}`;
                    instances.set(uniqueId, { text: token, weight: 1 });
                }
            });
            console.log(`üìä Created ${instances.size} word instances from ${answers.length} answers`);
            return instances;
        }

        // --- D3 Force Simulation Setup ---
        function initD3Simulation(layoutContext = null) {
            const layout = layoutContext || getLayoutMetrics();
            const containerWidth = layout.width;
            const containerHeight = layout.height;
            const centerW = layout.centerW;
            const centerH = layout.centerH;
            const paddingVals = layout.padding;

            if (d3Simulation) {
                d3Simulation.stop();
            }

            d3Simulation = d3.forceSimulation(wordParticles)
                .alphaDecay(0.002) // Slower decay for smooth settling
                .velocityDecay(0.4) // Lower friction for fluid movement
                .alphaMin(0.001)
                .force('charge', d3.forceManyBody().strength(-10))
                .force('wallRepulsion', alpha => {
                    const strength = 0.5 * alpha; // Strength of repulsion
                    wordParticles.forEach(p => {
                        const halfW = (p.width || DEFAULT_PARTICLE_WIDTH) / 2;
                        const halfH = (p.height || DEFAULT_PARTICLE_HEIGHT) / 2;

                        // Apply force away from walls
                        if (p.x - halfW < paddingVals.left) p.vx += (paddingVals.left - (p.x - halfW)) * strength;
                        if (p.x + halfW > containerWidth - paddingVals.right) p.vx -= ((p.x + halfW) - (containerWidth - paddingVals.right)) * strength;
                        if (p.y - halfH < paddingVals.top) p.vy += (paddingVals.top - (p.y - halfH)) * strength;
                        if (p.y + halfH > containerHeight - paddingVals.bottom) p.vy -= ((p.y + halfH) - (containerHeight - paddingVals.bottom)) * strength;
                    });
                })
                .force('collide', d3.forceCollide(d => {
                    const { width, height } = getParticleDimensions(d);
                    return Math.max(width, height) / 2 + 10;
                }).strength(1.0).iterations(24))
                .force('x', d3.forceX(d => d.targetX || centerW).strength(0.02))
                .force('y', d3.forceY(d => d.targetY || centerH).strength(0.02))
                .on('tick', () => {
                    wordParticles.forEach(p => {
                        if (p.fx !== null && p.fx !== undefined) return;

                        // Soft velocity limit
                        const speed = Math.hypot(p.vx || 0, p.vy || 0);
                        if (speed > MAX_PARTICLE_SPEED * 3) {
                            const ratio = (MAX_PARTICLE_SPEED * 3) / speed;
                            p.vx *= ratio;
                            p.vy *= ratio;
                        }

                        // Boundary Constraint with bounce
                        const paddingXWithClamp = Math.max(paddingVals.left, 40);
                        const paddingYWithClamp = Math.max(paddingVals.top, 40);
                        const halfW = (p.width || DEFAULT_PARTICLE_WIDTH) / 2;
                        const halfH = (p.height || DEFAULT_PARTICLE_HEIGHT) / 2;

                        let nextX = p.x + p.vx;
                        let nextY = p.y + p.vy;

                        if (nextX < paddingVals.left + halfW) {
                            p.x = paddingVals.left + halfW;
                            p.vx *= -0.2;
                        } else if (nextX > containerWidth - paddingVals.right - halfW) {
                            p.x = containerWidth - paddingVals.right - halfW;
                            p.vx *= -0.2;
                        } else {
                            p.x = nextX;
                        }

                        if (nextY < paddingVals.top + halfH) {
                            p.y = paddingVals.top + halfH;
                            p.vy *= -0.2;
                        } else if (nextY > containerHeight - paddingVals.bottom - halfH) {
                            p.y = containerHeight - paddingVals.bottom - halfH;
                            p.vy *= -0.2;
                        } else {
                            p.y = nextY;
                        }

                        // Update DOM
                        p.el.style.left = `${p.x}px`;
                        p.el.style.top = `${p.y}px`;

                        p.prevX = p.x;
                        p.prevY = p.y;
                    });
                });

            return d3Simulation;
        }

        // --- Legacy Simulation Loop (now simplified) ---
        function simulationLoop(timestamp = performance.now()) {
            if (!d3Simulation || wordParticles.length === 0) {
                if (wordParticles.length > 0) {
                    initD3Simulation();
                }
                animationFrameId = requestAnimationFrame(simulationLoop);
                return;
            }

            // D3 simulation handles everything via 'tick' event
            // We just need to keep the loop alive if we want to manually restart or check things
            // But D3 has its own timer. However, if we want continuous floating even after alpha settles,
            // we might need to restart alpha periodically or use a custom timer.
            // For now, let's rely on D3's internal timer which runs as long as alpha > alphaMin.
            // To make it "float forever", we can gently reheat alpha.

            if (d3Simulation.alpha() < 0.01) {
                d3Simulation.alpha(0.01).restart(); // Keep it alive gently
            }

            animationFrameId = requestAnimationFrame(simulationLoop);
        }

        function removeWordElement(wordEl, sourceText = '', options = {}) {
            const { trackHidden = true } = options;
            if (!wordEl || wordEl.classList.contains('concept-word-removing')) {
                return;
            }

            const normalizedText = (sourceText || wordEl.dataset.originalText || wordEl.textContent || '').trim();
            if (trackHidden && normalizedText && !hiddenWords.includes(normalizedText)) {
                hiddenWords.push(normalizedText);
            }

            wordEl.classList.add('concept-word-removing');

            const particleIndex = wordParticles.findIndex(p => p.el === wordEl);
            if (particleIndex !== -1) {
                wordParticles.splice(particleIndex, 1);
            }

            const finalizeRemoval = () => {
                if (wordEl.parentNode) {
                    wordEl.remove();
                }

                if (wordParticles.length > 0) {
                    updateParticleTargets();
                    if (d3Simulation) {
                        d3Simulation.nodes(wordParticles);
                        d3Simulation.alpha(0.3).restart();
                    }
                    if (!animationFrameId) {
                        simulationLoop(performance.now());
                    }
                } else {
                    wordsLayer.innerHTML = '<div class="concept-empty">Ï≤´ Î≤àÏß∏ Îã®Ïñ¥Î•º Í∏∞Îã§Î¶¨Í≥† ÏûàÏñ¥Ïöî</div>';
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                }
            };

            const fallbackRemoval = () => {
                wordEl.style.transition = 'opacity 0.45s ease-out, transform 0.45s ease-out';
                wordEl.style.opacity = '0';
                wordEl.style.transform = 'translate(-50%, -50%) scale(0.3)';
                setTimeout(finalizeRemoval, 460);
            };

            if (window.d3 && typeof window.d3.select === 'function') {
                try {
                    window.d3.select(wordEl)
                        .transition()
                        .duration(450)
                        .ease(window.d3.easeCubicOut)
                        .style('opacity', 0)
                        .style('transform', 'translate(-50%, -50%) scale(0.3)')
                        .on('end', finalizeRemoval)
                        .on('interrupt', finalizeRemoval);
                    return;
                } catch (error) {
                    console.warn('D3 removal failed, falling back to CSS animation:', error);
                }
            }

            fallbackRemoval();
        }

        function pruneOldestParticles(maxCount = MAX_DISPLAYED_WORDS) {
            // Intentionally noop: keep every word on screen regardless of count
            return;
        }

        function renderWords(frequencyMap) {
            const existingParticles = new Map();
            const now = performance.now();
            wordParticles.forEach(p => {
                if (!p.bornAt) p.bornAt = now;
                existingParticles.set(p.uniqueId, p);
            });

            if (frequencyMap.size === 0 && wordParticles.length === 0) {
                wordsLayer.innerHTML = '<div class="concept-empty">Ï≤´ Î≤àÏß∏ Îã®Ïñ¥Î•º Í∏∞Îã§Î¶¨Í≥† ÏûàÏñ¥Ïöî</div>';
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            } else if (frequencyMap.size > 0 && wordsLayer.querySelector('.concept-empty')) {
                wordsLayer.innerHTML = '';
            }

            const sortedWords = [...frequencyMap.entries()].sort((a, b) => b[1].weight - a[1].weight);
            console.log(`üìä Total unique instances: ${sortedWords.length}`);

            // Keep MAX_WORDS at 90 (no dynamic calculation)
            // MAX_WORDS is already set to 90

            const limited = sortedWords
                .filter(([id, data]) => !hiddenWords.includes((data.text || '').trim()))
                .slice(0, MAX_VISIBLE_WORDS);
            console.log(`üìä Displaying ${limited.length}/${sortedWords.length} words (cap ${MAX_VISIBLE_WORDS})`);
            const newWordIds = new Set(limited.map(item => item[0]));

            // Auto-deletion of old words when exceeding MAX_WORDS (90)
            wordParticles = wordParticles.filter(p => {
                if (!newWordIds.has(p.uniqueId)) {
                    if (now - (p.bornAt || now) < MIN_WORD_LIFETIME) {
                        return true;
                    }
                    p.el.classList.remove('concept-word-visible');
                    p.el.classList.add('concept-word-hidden');
                    setTimeout(() => p.el.remove(), 700);
                    return false;
                }
                return true;
            });


            const layout = getLayoutMetrics();
            const geometry = getSpiralGeometry(layout, limited.length);
            const { centerW, centerH } = layout;

            function addClickToDelete(wordEl, text) {
                if (!wordEl || wordEl.dataset.hasClickHandler === '1') return;
                wordEl.dataset.hasClickHandler = '1';
                wordEl.style.cursor = 'pointer';
                wordEl.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const normalizedText = (text || wordEl.dataset.originalText || '').trim();
                    removeWordElement(wordEl, normalizedText, { trackHidden: true });
                });
            }

            limited.forEach(([uniqueId, data], index) => {
                const text = data.text;
                const weight = data.weight;

                // Keep normal order: outer rings fill first, then move inward
                const spiralIndex = index;

                let particle = existingParticles.get(uniqueId);
                if (particle) {
                    // Existing particle - keep fixed font size, no changes
                    if (particle.phase !== 'intro') {
                        const oldSpiralIndex = particle.spiralIndex;
                        assignParticleTarget(particle, layout, geometry, spiralIndex);

                        // ÏàúÏúÑ(ÏúÑÏπò)Í∞Ä Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ÏóêÎßå Í≥†Ï†ï Ìï¥Ï†úÌïòÏó¨ Ïù¥Îèô ÌóàÏö©
                        if (oldSpiralIndex !== spiralIndex) {
                            particle.fx = null;
                            particle.fy = null;
                        }
                    }
                    particle.el.style.color = particle.color;

                    // Force horizontal writing mode - prevent vertical text
                    particle.el.style.writingMode = 'horizontal-tb';
                    particle.el.style.textOrientation = 'mixed';
                    particle.el.classList.remove('concept-word-vertical');

                    // Ensure click handler is attached to existing particles
                    addClickToDelete(particle.el, text);
                } else {
                    const wordEl = document.createElement('span');
                    wordEl.className = 'concept-word';

                    // Force horizontal rendering for all words
                    const isVertical = false;
                    applyWordLayout(wordEl, text);

                    const assignedColor = selectWordColor(1, index);
                    wordEl.style.color = assignedColor;

                    // Fixed font size for all words
                    const fontSize = FIXED_FONT_SIZE;
                    wordEl.style.fontSize = `${fontSize}px`;

                    // Extremely transparent pastel colors (CELL logo visible through)
                    const pastelStyles = [
                        '#f472b6', '#fbbf24', '#facc15', '#60a5fa', '#34d399', '#a78bfa', '#fda4af', '#fcd34d', '#6ee7b7'
                    ];
                    const pastelBase = pastelStyles[Math.floor(Math.random() * pastelStyles.length)];
                    wordEl.style.border = 'none';
                    wordEl.style.backgroundColor = `${pastelBase}30`; // ~19% alpha for better color
                    wordEl.style.boxShadow = 'none';

                    // Force horizontal writing mode - prevent vertical text
                    wordEl.style.writingMode = 'horizontal-tb';
                    wordEl.style.textOrientation = 'mixed';

                    // Add click to delete functionality
                    addClickToDelete(wordEl, text);


                    wordsLayer.appendChild(wordEl);

                    const rect = wordEl.getBoundingClientRect();
                    particle = {
                        el: wordEl,
                        uniqueId: uniqueId,
                        x: centerW,
                        y: centerH,
                        prevX: centerW,
                        prevY: centerH,
                        originX: centerW,
                        originY: centerH,
                        vx: 0,
                        vy: 0,
                        width: rect.width,
                        height: rect.height,
                        currentFontSize: fontSize,
                        targetFontSize: fontSize,
                        isVertical,
                        spiralIndex,
                        phase: 'stable',
                        spiralProgress: 0,
                        introDuration: 0,
                        introStart: null,
                        bornAt: now,
                        color: assignedColor
                    };
                    assignParticleTarget(particle, layout, geometry, spiralIndex);

                    // Start near target position with some randomness to prevent clumping
                    // This prevents words from appearing in a line at the top
                    const randomOffset = 30; // tighter spawn radius
                    const xJitter = particle.targetX + (Math.random() - 0.5) * randomOffset;
                    const yJitter = particle.targetY + (Math.random() - 0.5) * randomOffset;
                    const minX = layout.padding.left + LAYOUT_CLAMP_BUFFER_X;
                    const maxX = layout.width - layout.padding.right - LAYOUT_CLAMP_BUFFER_X;
                    const minY = layout.padding.top + LAYOUT_CLAMP_BUFFER_Y;
                    const maxY = layout.height - layout.padding.bottom - LAYOUT_CLAMP_BUFFER_Y;
                    particle.x = clampValue(xJitter, minX, maxX);
                    particle.y = clampValue(yJitter, minY, maxY);
                    particle.prevX = particle.x;
                    particle.prevY = particle.y;
                    wordEl.style.left = `${particle.x}px`;
                    wordEl.style.top = `${particle.y}px`;
                    wordParticles.push(particle);
                    const introParticles = wordParticles.filter(p => p.phase === 'intro');


                    requestAnimationFrame(() => {
                        wordEl.classList.add('concept-word-visible');
                        animateWordEntry(wordEl);
                    });
                }

                const weightRatio = weight / Math.max(...limited.map(item => item[1]));
                const isHero = weightRatio > 0.7;
                const isAccent = !isHero && weightRatio > 0.4;
                particle.el.classList.toggle('concept-word-hero', isHero);
                particle.el.classList.toggle('concept-word-accent', isAccent);
            });

            pruneOldestParticles(MAX_DISPLAYED_WORDS + 20);

            if (!animationFrameId && wordParticles.length > 0) {
                simulationLoop(performance.now());
            }

            // Update D3 simulation with new particles
            if (d3Simulation && wordParticles.length > 0) {
                d3Simulation.nodes(wordParticles);
                d3Simulation.alpha(0.3).restart(); // Higher alpha restart for more movement on new words
            }
        }

        // --- Data Fetching & Control ---
        // No longer needed - using broadcast only

        function stopMockSimulation() {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
        }

        function stopAllIntervals() {
            if (realtimeChannel) {
                supabase.removeChannel(realtimeChannel);
                realtimeChannel = null;
            }
            if (simulationInterval) clearInterval(simulationInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (d3Simulation) d3Simulation.stop();
            simulationInterval = null;
            animationFrameId = null;
            d3Simulation = null;
        }

        function resetDisplay() {
            console.log('resetDisplay called');
            stopAllIntervals();
            mockAnswers = [];
            wordParticles = [];
            hiddenWords = [];
            wordsLayer.innerHTML = '';
            totalAnswerCount = 0;
            conceptTotal.textContent = '0';
            stopTimer();
            conceptUpdated.textContent = '02:00';
            isTimerExpired = false;
            timerDeadline = null;
            isMockPaused = false;
            pausedTimerRemaining = null;
            mockGeneratedCount = 0;
            seenAnswerIds.clear();
            updateMockButtonState();
            ensureQrVisible();
        }

        function startRealtimeSimulation(options = {}) {
            const { reset = true } = options;
            console.log('startRealtimeSimulation called', reset ? '(with reset)' : '(resume)');
            if (reset) {
                resetDisplay();
                startTimer();
            } else {
                stopMockSimulation();
            }
            let count = reset ? 0 : mockGeneratedCount;
            const question = QUESTIONS[currentQuestionIndex];
            MAX_WORDS = calculateMaxWords();

            function generateSingleMockAnswer(questionId, index) {
                const currentQuestion = QUESTIONS.find(q => q.id === questionId);
                let answer;

                if (currentQuestion && currentQuestion.type === 'text') {
                    answer = TEXT_ANSWERS[Math.floor(Math.random() * TEXT_ANSWERS.length)];
                } else {
                    answer = KEYWORDS[Math.floor(Math.random() * KEYWORDS.length)] || KEYWORDS[index % KEYWORDS.length];
                }

                // Apply 12 character limit (excluding spaces)
                const textWithoutSpaces = answer.replace(/\s+/g, '');
                if (textWithoutSpaces.length > MAX_INPUT_CHARS) {
                    // Find the position in original string that gives us MAX_INPUT_CHARS non-space characters
                    let charCount = 0;
                    let cutIndex = 0;
                    for (let i = 0; i < answer.length; i++) {
                        if (answer[i] !== ' ') charCount++;
                        if (charCount === MAX_INPUT_CHARS) {
                            cutIndex = i + 1;
                            break;
                        }
                    }
                    answer = answer.substring(0, cutIndex);
                }

                return {
                    id: `${questionId}-${index}-${Date.now()}`,
                    question_id: questionId,
                    answer: answer,
                    answer_text: answer,
                    created_at: new Date().toISOString()
                };
            }

            simulationInterval = setInterval(() => {
                if (isTimerExpired) {
                    console.log('‚èπÔ∏è Mock generator halted: timer expired');
                    stopMockSimulation();
                    return;
                }
                const TARGET_MOCK_WORDS = 200; // Increased to 200 for mock mode

                if (count >= 2000) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    return;
                }

                const remainingSlots = Math.max(0, TARGET_MOCK_WORDS - mockAnswers.length);
                if (remainingSlots <= 0) {
                    console.log(`üõë Mock target of ${TARGET_MOCK_WORDS} words reached.`);
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    return;
                }

                const batchSize = Math.min(MOCK_BATCH_SIZE, remainingSlots);
                for (let i = 0; i < batchSize; i++) {
                    const newAnswer = generateSingleMockAnswer(question.id, count + i);
                    mockAnswers.unshift(newAnswer);
                }
                if (mockAnswers.length > MAX_VISIBLE_WORDS) {
                    const removed = mockAnswers.length - MAX_VISIBLE_WORDS;
                    mockAnswers = mockAnswers.slice(0, MAX_VISIBLE_WORDS);
                    console.log(`üßπ Trimmed ${removed} mock answers to keep latest ${MAX_VISIBLE_WORDS}`);
                }
                const frequencyMap = extractWordInstances(mockAnswers);
                renderWords(frequencyMap);
                totalAnswerCount += batchSize;
                conceptTotal.textContent = totalAnswerCount.toString();
                count += batchSize;
                mockGeneratedCount = count;
            }, MOCK_BATCH_INTERVAL);

            // Simulation loop is started by renderWords if words exist
        }

        function pauseMockSimulation() {
            if (!isMockMode || isMockPaused) return;
            console.log('‚è∏Ô∏è Pausing mock simulation');
            isMockPaused = true;
            pausedTimerRemaining = timerDeadline ? Math.max(0, timerDeadline - Date.now()) : null;
            stopMockSimulation();
            stopTimer();
            updateMockButtonState();
            startRealtimeSubscription({ preserveScene: true });
        }

        function resumeMockSimulation() {
            if (!isMockMode || !isMockPaused) return;
            console.log('‚ñ∂Ô∏è Resuming mock simulation');
            isMockPaused = false;
            if (pausedTimerRemaining !== null) {
                timerDeadline = Date.now() + pausedTimerRemaining;
                updateTimerDisplay();
                timerInterval = setInterval(updateTimerDisplay, 1000);
                pausedTimerRemaining = null;
            } else {
                startTimer();
            }
            startRealtimeSimulation({ reset: false });
            updateMockButtonState();
        }

        async function startRealtimeSubscription(options = {}) {
            const { preserveScene = false } = options;
            console.log('startRealtimeSubscription called', preserveScene ? '(preserving scene)' : '');

            if (preserveScene) {
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
            } else {
                stopAllIntervals();
                mockAnswers = [];
                wordParticles = [];
                hiddenWords = [];
                wordsLayer.innerHTML = '';
                totalAnswerCount = 0;
                conceptTotal.textContent = '0';
                stopTimer();
                conceptUpdated.textContent = '02:00';
                isTimerExpired = false;
                seenAnswerIds.clear();
            }

            const question = QUESTIONS[currentQuestionIndex];
            if (!question) return;

            if (!preserveScene) {
                startTimer();
            }

            // Poll for new answers every 2 seconds (only show answers submitted after this viewer started)
            console.log('üîÑ Starting polling for new answers...');
            seenAnswerIds.clear();
            sessionStartTime = Date.now();
            console.log('üìç Session started at:', new Date(sessionStartTime).toISOString());
            simulationInterval = setInterval(async () => {
                try {
                    const { data: newAnswers, error } = await supabase
                        .from('answers')
                        .select('*')
                        .eq('question_id', question.id)
                        .gte('created_at', new Date(sessionStartTime).toISOString())
                        .order('created_at', { ascending: false })
                        .limit(200);

                    if (error) {
                        console.error('Polling error:', error);
                        return;
                    }

                    if (newAnswers && newAnswers.length > 0) {
                        console.log(`üîÑ Polled ${newAnswers.length} answers`);

                        const freshAnswers = [];
                        newAnswers.forEach(a => {
                            if (!seenAnswerIds.has(a.id)) {
                                seenAnswerIds.add(a.id);
                                freshAnswers.push(a);
                            }
                        });

                        if (freshAnswers.length > 0) {
                            console.log(`‚ú® Found ${freshAnswers.length} new answers`);
                            freshAnswers.forEach(a => {
                                const newAnswer = {
                                    id: a.id,
                                    question_id: a.question_id,
                                    answer: a.answer_text,
                                    answer_text: a.answer_text,
                                    created_at: a.created_at
                                };
                                mockAnswers.unshift(newAnswer);
                            });

                            if (mockAnswers.length > MAX_VISIBLE_WORDS) {
                                const removed = mockAnswers.length - MAX_VISIBLE_WORDS;
                                mockAnswers = mockAnswers.slice(0, MAX_VISIBLE_WORDS);
                                console.log(`üßπ Trimmed ${removed} realtime answers to keep latest ${MAX_VISIBLE_WORDS}`);
                            }

                            const frequencyMap = extractWordInstances(mockAnswers);
                            renderWords(frequencyMap);
                            totalAnswerCount += freshAnswers.length;
                            conceptTotal.textContent = totalAnswerCount.toString();
                        }
                    }
                } catch (err) {
                    console.error('Polling exception:', err);
                }
            }, 2000); // Poll every 2 seconds
        }

        // --- Event Listeners ---
        // Intentionally no click-to-remove handler so displayed words persist

        if (toggleMockBtn) {
            toggleMockBtn.addEventListener('click', () => {
                if (!isMockMode) {
                    isMockMode = true;
                    isMockPaused = false;
                    updateMockButtonState();
                    ensureQrVisible();
                    navigateToQuestion(currentQuestionIndex, { force: true, preserveQr: true });
                    return;
                }

                if (isMockPaused) {
                    ensureQrVisible();
                    resumeMockSimulation();
                } else {
                    ensureQrVisible();
                    pauseMockSimulation();
                }
            });
        }

        window.addEventListener('resize', () => {
            updateParticleTargets();
        });

        updateMockButtonState();
        ensureQrVisible();
        startClock();

        // --- Initial Load ---
        navigateToQuestion(0, { force: true });
    </script>
</body>

</html>
