<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Word Animation - Concept</title>
    <style>
        @font-face {
            font-family: 'ê°•ì›êµìœ¡ëª¨ë‘';
            src: url('./fonts/ê°•ì›êµìœ¡ëª¨ë‘ Bold.otf') format('opentype');
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }



        body {
            font-family: 'ê°•ì›êµìœ¡ëª¨ë‘', cursive, -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            width: 90vw;
            max-width: 1200px;
            height: 80vh;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .title {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #333;
            z-index: 100;
        }

        .word-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .word {
            position: absolute;
            font-size: 24px;
            font-weight: 600;
            padding: 14px 26px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 5px 18px rgba(0, 0, 0, 0.18);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            white-space: nowrap;
            isolation: isolate;
            /* allow pseudo elements to sit underneath */
        }

        .word::before {
            content: '';
            position: absolute;
            inset: -12px -20px;
            border-radius: 999px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4));
            box-shadow: inset 0 2px 6px rgba(255, 255, 255, 0.5), 0 8px 20px rgba(94, 79, 162, 0.25);
            z-index: -1;
        }

        .word:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
        }

        .ground {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }

        .info {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .info-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .concept-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="title">ğŸ® í…ŒíŠ¸ë¦¬ìŠ¤ ìŠ¤íƒ€ì¼ ë‹¨ì–´ ì• ë‹ˆë©”ì´ì…˜</div>

        <div class="info">
            <div class="info-label">ëˆ„ì  ë‹µë³€</div>
            <div class="info-value" id="totalCount">0</div>
        </div>

        <div class="word-container" id="wordContainer">
            <div class="ground"></div>
        </div>

        <div class="concept-label">
            ë‹¨ì–´ë¥¼ í´ë¦­í•˜ë©´ ì‚¬ë¼ì§‘ë‹ˆë‹¤ â€¢ ìœ„ì—ì„œ ë–¨ì–´ì ¸ì„œ ìŒ“ì…ë‹ˆë‹¤
        </div>
    </div>

    <script>
        const WORDS = ['ê°ì‚¬', 'ê¸°ì¨', 'í‰ì•ˆ', 'ì€í˜œ', 'íšŒê°œ', 'ì°¬ì–‘', 'ê²½ë°°', 'ì‚¬ë‘', 'ì†Œë§', 'ë¯¿ìŒ',
            'ê²¸ì†', 'ìˆœì¢…', 'ê°ê²©', 'ê¸°ëŒ€', 'ì¶•ë³µ', 'íšŒë³µ', 'ì¹˜ìœ ', 'ìƒˆí˜', 'ê°ë™', 'ê¸°ë„',
            'ê°„ì ˆí•¨', 'ëœ¨ê±°ì›€', 'ì¶©ë§Œ', 'í‰ì˜¨', 'ê¸°ë‹¤ë¦¼', 'ê°ˆë§', 'ê°„êµ¬', 'ê³ ë°±', 'í—Œì‹ '];

        const COLORS = ['#5e4fa2', '#3288bd', '#66c2a5', '#fdae61', '#f46d43', '#d53e4f', '#9e0142'];

        const wordContainer = document.getElementById('wordContainer');
        const totalCount = document.getElementById('totalCount');

        let stackedWords = [];
        let wordCount = 0;
        let wordFrequency = new Map();

        const COLUMN_COUNT = 6;
        const COLUMN_GAP = 10;
        const COLUMN_SPACING_X = 24;
        const HORIZONTAL_PADDING = 60;
        const GROUND_CLEARANCE = 30;
        const FALL_SPEED = 320; // pixels per second
        const FALL_START_OFFSET = 120; // start drop slightly above the viewport
        const BUBBLE_MARGIN_X = 20;
        const BUBBLE_MARGIN_Y = 12;
        const DROP_DELAY_MIN = 400;
        const DROP_DELAY_MAX = 900;
        let columnHeights = new Array(COLUMN_COUNT).fill(0);
        let dropTimeoutId = null;

        function createWord() {
            wordCount++;
            totalCount.textContent = wordCount;

            const wordText = WORDS[Math.floor(Math.random() * WORDS.length)];

            // Update frequency
            wordFrequency.set(wordText, (wordFrequency.get(wordText) || 0) + 1);

            // Find existing word or create new
            let existingWord = stackedWords.find(w => w.text === wordText);

            if (existingWord) {
                // Flash effect for existing word
                existingWord.element.style.transition = 'transform 0.2s, box-shadow 0.2s';
                existingWord.element.style.transform = 'scale(1.2)';
                existingWord.element.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.3)';

                setTimeout(() => {
                    existingWord.element.style.transform = 'scale(1)';
                    existingWord.element.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
                }, 200);
                scheduleNextDrop(400);
                return 0;
            }

            const word = document.createElement('div');
            word.className = 'word';
            word.textContent = wordText;
            word.style.color = COLORS[Math.floor(Math.random() * COLORS.length)];

            const containerWidth = wordContainer.offsetWidth;
            const containerHeight = wordContainer.offsetHeight;

            wordContainer.appendChild(word);

            const wordWidth = word.offsetWidth;
            const wordHeight = word.offsetHeight;
            const bubbleWidth = wordWidth + BUBBLE_MARGIN_X * 2;
            const bubbleHeight = wordHeight + BUBBLE_MARGIN_Y * 2;
            const columnIndex = pickColumn();
            const landingHeight = columnHeights[columnIndex];
            const left = calculateColumnLeft(columnIndex, bubbleWidth, containerWidth);
            const finalTop = calculateFinalTop(landingHeight, bubbleHeight, wordHeight, containerHeight);

            word.style.left = `${left}px`;
            word.style.top = `${-bubbleHeight - 40}px`;

            const fallDistance = finalTop + FALL_START_OFFSET;
            const duration = Math.max(0.8, Math.abs(fallDistance) / FALL_SPEED);

            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    word.style.transition = `top ${duration}s linear, transform 0.2s, box-shadow 0.2s`;
                    word.style.top = `${finalTop}px`;
                });
            });

            columnHeights[columnIndex] = landingHeight + bubbleHeight + COLUMN_GAP;

            const wordData = {
                element: word,
                text: wordText,
                width: wordWidth,
                height: wordHeight,
                bubbleWidth,
                bubbleHeight,
                column: columnIndex,
                bottom: landingHeight,
                top: finalTop
            };

            stackedWords.push(wordData);

            word.addEventListener('click', () => {
                removeWord(word, wordText);
            });

            scheduleNextDrop(duration * 1000);
            return duration * 1000;
        }

        function scheduleNextDrop(previousDuration = 0) {
            if (dropTimeoutId) {
                clearTimeout(dropTimeoutId);
            }
            const delay = Math.max(DROP_DELAY_MIN, previousDuration) + Math.random() * (DROP_DELAY_MAX - DROP_DELAY_MIN);
            dropTimeoutId = setTimeout(createWord, delay);
        }

        function removeWord(wordElement, wordText) {
            const index = stackedWords.findIndex(w => w.element === wordElement);
            if (index === -1) return;

            const removedWord = stackedWords[index];

            // Fade out animation
            wordElement.style.transition = 'opacity 0.3s, transform 0.3s';
            wordElement.style.opacity = '0';
            wordElement.style.transform = 'scale(0.8)';

            setTimeout(() => {
                wordElement.remove();
                stackedWords.splice(index, 1);
                layoutStackedWords(removedWord.column);
            }, 300);
        }

        function pickColumn() {
            const minHeight = Math.min(...columnHeights);
            const threshold = minHeight + 60;
            const preferred = columnHeights
                .map((height, index) => ({ height, index }))
                .filter(col => col.height <= threshold);
            const pool = preferred.length ? preferred : columnHeights.map((height, index) => ({ height, index }));
            const choice = pool[Math.floor(Math.random() * pool.length)];
            return choice.index;
        }

        function calculateColumnLeft(columnIndex, bubbleWidth, containerWidth = wordContainer.offsetWidth) {
            const totalSpacing = (COLUMN_COUNT - 1) * COLUMN_SPACING_X;
            const availableWidth = Math.max(containerWidth - HORIZONTAL_PADDING * 2 - totalSpacing, 120);
            const baseColumnWidth = availableWidth / COLUMN_COUNT;
            const columnStart = HORIZONTAL_PADDING + columnIndex * (baseColumnWidth + COLUMN_SPACING_X);
            const rawLeft = columnStart + (baseColumnWidth - bubbleWidth) / 2;
            const minLeft = HORIZONTAL_PADDING;
            const maxLeft = containerWidth - HORIZONTAL_PADDING - bubbleWidth;
            const upperBound = Math.max(minLeft, maxLeft);
            const bubbleLeft = Math.min(Math.max(rawLeft, minLeft), upperBound);
            return bubbleLeft + BUBBLE_MARGIN_X;
        }

        function calculateFinalTop(stackHeight, bubbleHeight, wordHeight, containerHeight = wordContainer.offsetHeight) {
            const elementBottomOffset = GROUND_CLEARANCE + stackHeight + BUBBLE_MARGIN_Y;
            const top = containerHeight - (elementBottomOffset + wordHeight);
            return Math.min(top, containerHeight - bubbleHeight - GROUND_CLEARANCE + BUBBLE_MARGIN_Y);
        }

        function layoutStackedWords(targetColumnIndex) {
            const containerWidth = wordContainer.offsetWidth;
            const containerHeight = wordContainer.offsetHeight;
            const columnsToProcess = typeof targetColumnIndex === 'number'
                ? [targetColumnIndex]
                : [...Array(COLUMN_COUNT).keys()];

            columnsToProcess.forEach(columnIndex => {
                const wordsInColumn = stackedWords
                    .filter(w => w.column === columnIndex)
                    .sort((a, b) => a.bottom - b.bottom);

                let height = 0;
                wordsInColumn.forEach(word => {
                    const wordWidth = word.element.offsetWidth;
                    const wordHeight = word.element.offsetHeight;
                    const bubbleWidth = wordWidth + BUBBLE_MARGIN_X * 2;
                    const bubbleHeight = wordHeight + BUBBLE_MARGIN_Y * 2;
                    const left = calculateColumnLeft(columnIndex, bubbleWidth, containerWidth);
                    const top = calculateFinalTop(height, bubbleHeight, wordHeight, containerHeight);

                    word.width = wordWidth;
                    word.height = wordHeight;
                    word.bubbleWidth = bubbleWidth;
                    word.bubbleHeight = bubbleHeight;
                    word.bottom = height;
                    word.top = top;

                    word.element.style.transition = 'top 0.4s ease, left 0.4s ease, transform 0.2s, box-shadow 0.2s';
                    word.element.style.left = `${left}px`;
                    word.element.style.top = `${top}px`;

                    height += bubbleHeight + COLUMN_GAP;
                });

                columnHeights[columnIndex] = height;
            });
        }

        // Start dropping words sequentially
        createWord();

        // Handle window resize
        window.addEventListener('resize', () => {
            layoutStackedWords();
        });
    </script>
</body>

</html>